/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. 
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file
 *
 * @Author christian liesch <liesch@gmx.ch>
 *
 * Implementation of the HTTP Test Tool.
 */

/* affects include files on Solaris */
#define BSD_COMP

/************************************************************************
 * Includes
 ***********************************************************************/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <openssl/ssl.h>
#include <openssl/rsa.h>
#include <openssl/crypto.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <openssl/rand.h>
#define USE_SSL
#define SK_NUM(x) sk_X509_num(x)
#define SK_VALUE(x,y) sk_X509_value(x,y)
typedef STACK_OF(X509) X509_STACK_TYPE;

#include <pcre.h>

#include <apr.h>
#include <apr_signal.h>
#include <apr_strings.h>
#include <apr_network_io.h>
#include <apr_file_io.h>
#include <apr_time.h>
#include <apr_getopt.h>
#include <apr_general.h>
#include <apr_lib.h>
#include <apr_portable.h>
#include <apr_thread_proc.h>
#include <apr_thread_cond.h>
#include <apr_thread_mutex.h>
#include <apr_support.h>
#include <apr_hash.h>
#include <apr_base64.h>
#include <apr_env.h>
#include <unistd.h>             /* for getpid() */

#include "util.h"

/************************************************************************
 * Globals 
 ***********************************************************************/

     static apr_status_t htt_cmd_REQ(htt_cmd_t * self, htt_worker_t * worker,
                                     char *data);
     static apr_status_t htt_cmd_RES(htt_cmd_t * self, htt_worker_t * worker,
                                     char *data);
     static apr_status_t htt_cmd_WAIT(htt_cmd_t * self, htt_worker_t * worker,
                                      char *data);
     static apr_status_t htt_cmd_SLEEP(htt_cmd_t * self,
                                       htt_worker_t * worker, char *data);
     static apr_status_t htt_cmd_EXPECT(htt_cmd_t * self,
                                        htt_worker_t * worker, char *data);
     static apr_status_t htt_cmd_CLOSE(htt_cmd_t * self,
                                       htt_worker_t * worker, char *data);
     static apr_status_t htt_cmd_TIMEOUT(htt_cmd_t * self,
                                         htt_worker_t * worker, char *data);
     static apr_status_t htt_cmd_MATCH(htt_cmd_t * self,
                                       htt_worker_t * worker, char *data);
     static apr_status_t htt_cmd_SET(htt_cmd_t * self, htt_worker_t * worker,
                                     char *data);
     static apr_status_t htt_cmd_IF(htt_cmd_t * self, htt_worker_t * worker,
                                    char *data);
     static apr_status_t htt_cmd_DATA(htt_cmd_t * self, htt_worker_t * worker,
                                      char *data);
     static apr_status_t htt_cmd_FLUSH(htt_cmd_t * self, htt_worker_t * worker,
                                       char *data);
     static apr_status_t htt_cmd_CHUNK(htt_cmd_t * self, htt_worker_t * worker,
                                       char *data);
     static apr_status_t htt_cmd_EXEC(htt_cmd_t * self, htt_worker_t * worker,
                                      char *data);
     static apr_status_t htt_cmd_SENDFILE(htt_cmd_t * self, htt_worker_t * worker,
                                          char *data);
     static apr_status_t htt_cmd_PIPE(htt_cmd_t * self, htt_worker_t * worker,
                                       char *data);
     static apr_status_t htt_cmd_NOCRLF(htt_cmd_t * self, htt_worker_t * worker,
                                        char *data);
     static apr_status_t htt_cmd_SOCKSTATE(htt_cmd_t * self, htt_worker_t * worker,
                                           char *data);
     static apr_status_t htt_cmd_IGNORE_ERR(htt_cmd_t * self, htt_worker_t * worker,
                                               char *data);
     static apr_status_t htt_cmd_EXIT(htt_cmd_t * self, htt_worker_t * worker,
                                      char *data);
     static apr_status_t htt_cmd_HEADER(htt_cmd_t *self, htt_worker_t *worker, 
	                                char *data);
     static apr_status_t htt_cmd_LOOP(htt_cmd_t *self, htt_worker_t *worker, 
	                              char *data);
     static apr_status_t htt_cmd_RAND(htt_cmd_t *self, htt_worker_t *worker, 
	                              char *data);
     static apr_status_t htt_cmd_DEBUG(htt_cmd_t *self, htt_worker_t *worker, 
	                               char *data);
     static apr_status_t htt_cmd_UP(htt_cmd_t *self, htt_worker_t *worker, 
	                            char *data);
     static apr_status_t htt_cmd_DOWN(htt_cmd_t *self, htt_worker_t *worker, 
	                              char *data);
     static apr_status_t htt_cmd_TIME(htt_cmd_t *self, htt_worker_t *worker, 
	                              char *data);
     static apr_status_t htt_cmd_CALL(htt_cmd_t *self, htt_worker_t *worker,
	                              char *data);
     static apr_status_t htt_cmd_LOG_LEVEL(htt_cmd_t *self, htt_worker_t *worker,
	                                   char *data);
     static apr_status_t htt_cmd_SYNC(htt_cmd_t *self, htt_worker_t *worker,
	                              char *data);
     static apr_status_t htt_cmd_RECV(htt_cmd_t * self, htt_worker_t * worker,
                                      char *data);
     static apr_status_t htt_cmd_OP(htt_cmd_t * self, htt_worker_t * worker,
                                    char *data);
     static apr_status_t htt_cmd_WHICH(htt_cmd_t * self, htt_worker_t * worker,
                                       char *data);
     static apr_status_t htt_cmd_CERT(htt_cmd_t * self, htt_worker_t * worker,
                                      char *data);
     static apr_status_t htt_cmd_VERIFY_PEER(htt_cmd_t *self, htt_worker_t * worker,
	                                   char *data);

     static apr_status_t htt_global_GO(htt_cmd_t *self, htt_global_t *global, 
	                           char *data); 
     static apr_status_t htt_global_END(htt_cmd_t *self, htt_global_t *global, 
	                            char *data); 
     static apr_status_t htt_global_DAEMON(htt_cmd_t *self, htt_global_t *global, 
	                               char *data); 
     static apr_status_t htt_global_BLOCK(htt_cmd_t *self, htt_global_t *global,
	                              char *data);
     static apr_status_t htt_global_CLIENT(htt_cmd_t *self, htt_global_t *global, 
	                               char *data); 
     static apr_status_t htt_global_SERVER(htt_cmd_t *self, htt_global_t *global, 
	                               char *data); 
     static apr_status_t htt_global_EXEC(htt_cmd_t *self, htt_global_t *global, 
	                             char *data); 
     static apr_status_t htt_global_SET(htt_cmd_t *self, htt_global_t *global, 
	                            char *data); 
     static apr_status_t htt_global_INCLUDE(htt_cmd_t *self, htt_global_t *global, 
	                                char *data); 
     static apr_status_t htt_global_TIMEOUT(htt_cmd_t *self, htt_global_t *global, 
	                                char *data); 

     htt_cmd_t htt_global_commands[] = {
       {"END", (htt_cmd_f )htt_global_END, "", 
	"Close CLIENT|SERVER body"},
       {"CLIENT", (htt_cmd_f )htt_global_CLIENT, "[<number of concurrent clients>]", 
	"Client body start, close it with END and a newline"},
       {"SERVER", (htt_cmd_f )htt_global_SERVER, "[<SSL>:]<port> [<number of concurrent servers>]", 
	"Server body start, close it with END and a newline,\n"
	"Do load server.cert.pem and server.key.pem if found in local directory,\n"
        "number of concurrent servers, -1 for unlimited,\n"
        "<SSL>: SSL, SSL2, SSL3, TLS"},
       {"EXEC", (htt_cmd_f )htt_global_EXEC, "<shell command>", 
	"Execute a shell command, attention executes will not join CLIENT/SERVER"},
       {"SET", (htt_cmd_f )htt_global_SET, "<variable>=<value>", 
	"Store a value in a global variable"},
       {"INCLUDE", (htt_cmd_f )htt_global_INCLUDE, "<include file>", 
	"Load and execute defined include file,\n"
	"current path is taken the callers current path"},
       {"TIMEOUT", (htt_cmd_f )htt_global_TIMEOUT, "<timeout in ms>", 
	"Defines global socket timeout"},
       {"GO", (htt_cmd_f )htt_global_GO, "", 
	"Starts all client in sync mode"},
       {"BLOCK", (htt_cmd_f )htt_global_BLOCK, "<name>", 
	"Store a block of commands to call it from a CLIENT/SERVER/BLOCK"},
       {"DAEMON", (htt_cmd_f )htt_global_DAEMON, "", 
	"Daemon body start, close it with END and a newline. \n"
        "A daemon will not join CLIENT/SERVER and could therefore be used\n"
        "for supervisor jobs" },
       {NULL, NULL, NULL,
	NULL }
     };

     htt_cmd_t local_commands[] = {
       {"__", (htt_cmd_f )htt_cmd_DATA, "<string>", 
	"Send <string> to the socket with a CRLF at the end of line"},
       {"_-", (htt_cmd_f )htt_cmd_NOCRLF, "<string>", 
	"Same like __ but no CRLF at the end of line"},
       {"_FLUSH", (htt_cmd_f )htt_cmd_FLUSH, "", 
	"Flush the cached lines, \n"
	"the AUTO Content-Length calculation will take place here"},
       {"_CHUNK", (htt_cmd_f )htt_cmd_CHUNK, "", 
	"Mark the end of a chunk block, all data after last _FLUSH are counted,\n"
	"does automatic add chunk info"},
       {"_REQ", (htt_cmd_f )htt_cmd_REQ, "<host> [<SSL>:]<port>[:<tag>] [<cert-file> <key-file> [<ca-cert-file>]]", 
	"Start a request to defined host:port, with SSL support.\n"
	"Does only open a new connection if we are in connection state CLOSED\n"
        "<SSL>: SSL, SSL2, SSL3, TLS"
	"<tag>:Additional tag info do support multiple connection to one target\n"
        "<cert-file>, <key-file> and <ca-cert-file> are optional for client/server authentication"},	
       {"_RES", (htt_cmd_f )htt_cmd_RES, "", 
	"Wait for a connection accept"},
       {"_WAIT", (htt_cmd_f )htt_cmd_WAIT, "[<amount of bytes>]", 
	"Wait for data and receive them.\n"
	"EXPECT and MATCH definitions will be checked here on the incoming data.\n"
        "Optional you could receive a specific amount of bytes" },
       {"_CLOSE", (htt_cmd_f )htt_cmd_CLOSE, "", 
	"Close the current connection and set the connection state to CLOSED"},
       {"_EXPECT", (htt_cmd_f )htt_cmd_EXPECT, ". \"[!]<regex>\"", 
	"Define what data we do or do not expect on a WAIT command.\n"
        "Negation with a leading '!' in the <regex>"},
       {"_MATCH", (htt_cmd_f )htt_cmd_MATCH, "(header|body|error) \"<regex>\" <variable>", 
	 "Define a regex with a match which should be stored in <variable>"},
       {"_IF", (htt_cmd_f )htt_cmd_IF, "\"<expression>\" MATCH \"[!]<regex>\"", 
	"Test if variable do or do not match the regex, close body with _END IF,\n"
        "negation with a leading '!' in the <regex>,\n"
	"<expression> must not be empty"},
       {"_LOOP", (htt_cmd_f )htt_cmd_LOOP, "<n>", 
	"Loop body start end with _END do loop the body <n> times,\n"
	"close body with _END LOOP"},
       {"_SLEEP", (htt_cmd_f )htt_cmd_SLEEP, "<milisecond>", 
	 "Sleep for defined amount of time"},
       {"_TIMEOUT", (htt_cmd_f )htt_cmd_TIMEOUT, "<milisecond", 
	 "Set socket timeout of current socket"},
       {"_SET", (htt_cmd_f )htt_cmd_SET, "<variable>=<value>", 
	"Store a value in a local variable"},
       {"_EXEC", (htt_cmd_f )htt_cmd_EXEC, "<shell command>", 
	"Execute a shell command, _EXEC| will pipe the incoming stream on the\n"
        "socket in to the called shell command"},
       {"_PIPE", (htt_cmd_f )htt_cmd_PIPE, "[chunked [<chunk_size>]]", 
	"Start a pipe for stream the output of EXEC to the socket stream,\n" 
	"wiht optional chunk support"},
       {"_SOCKSTATE", (htt_cmd_f )htt_cmd_SOCKSTATE, "<variable>", 
	"Stores connection state CLOSED or CONNECTED in the <variable>"},
       {"_IGNORE_ERR", (htt_cmd_f )htt_cmd_IGNORE_ERR, "<regex>", 
	"Ignores errors specified in <regex>, \n"
	"i.e. \".*\" would ignore all errors"},
       {"_EXIT", (htt_cmd_f )htt_cmd_EXIT, "[OK|FAILED]", 
	"Exits with OK or FAILED default is FAILED"},
       {"_HEADER", (htt_cmd_f )htt_cmd_HEADER, "ALLOW|FILTER <header name>", 
	"Defines allowed headers or headers to filter,\n"
	"default all headers are allowed and no headers are filtered.\n"
	"Filter only for receive mechanisme"},
       {"_RAND", (htt_cmd_f )htt_cmd_RAND, "<start> <end>", 
	"Generates a number between <start> and <end>"},
       {"_SENDFILE", (htt_cmd_f )htt_cmd_SENDFILE, "<file>", 
	"Send file over http"},
       {"_DEBUG", (htt_cmd_f )htt_cmd_DEBUG, "<string>", 
	"Prints to stderr for debugging reasons"},
       {"_UP", (htt_cmd_f )htt_cmd_UP, "", 
	"Setup listener"},
       {"_DOWN", (htt_cmd_f )htt_cmd_DOWN, "", 
	"Shutdown listener"},
       {"_TIME", (htt_cmd_f )htt_cmd_TIME, "<variable>", 
	"Store time in variable [ms]"},
       {"_CALL", (htt_cmd_f )htt_cmd_CALL, "<name of block>", 
	"Call a defined block"},
       {"_LOG_LEVEL", (htt_cmd_f )htt_cmd_LOG_LEVEL, "<level>", 
	"Level is a number 0-4"},
       {"_SYNC", (htt_cmd_f )htt_cmd_SYNC, "", 
	"Synchronise to the next full second"},
       {"_RECV", (htt_cmd_f )htt_cmd_RECV, "<bytes>|POLL", 
	"Receive an amount of bytes, either specified by a number \n"
	"or as much until socket timeout will in POLL mode"},
       {"_OP", (htt_cmd_f )htt_cmd_OP, "<left> ADD|SUB|DIV|MUL <right> <variable>", 
	"Store evaluated expression"},
       {"_WHICH", (htt_cmd_f )htt_cmd_WHICH, "<variable>", 
	"Stores the concurrency number of current thread"},
       {"_CERT", (htt_cmd_f )htt_cmd_CERT, "<cert-file> <key-file> [<ca-cert-file>]", 
	"Sets cert for the current ssl connection, mainly used for server cert"},
       {"_VERIFY_PEER", (htt_cmd_f )htt_cmd_VERIFY_PEER, "", 
	"Gets peer cert and validate it"},
       {NULL, NULL, NULL, 
	NULL},
     };

     int success = 1;
     
/************************************************************************
 * Private 
 ***********************************************************************/


/**
 * Receive data from socket in http style
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN aditional data
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_WAIT(htt_cmd_t * self, htt_worker_t * worker,
                                 char *data) {
  int matches;
  int expects;
  char *line;
  char *buf;
  char *copy;
  apr_status_t status;
  htt_sockio_t *sockio;
  apr_table_t *headers;
  apr_pool_t *pool;
  char *last;
  char *key;
  const char *val = "";
  apr_size_t len;
  apr_ssize_t recv_len = -1;
  int i;
  apr_exit_why_e exitwhy;
  int exitcode;
  apr_size_t inlen;

  buf = NULL;
  i = 0;
  len = 0;
  matches = 0;
  expects = 0;

  HTT_CMD_OPTIONAL_ARG;

  if ((status = htt_worker_flush(worker)) != APR_SUCCESS) {
    return status;
  }

  if (apr_isdigit(copy[0])) {
    recv_len = apr_atoi64(copy);
  }
  else {
    recv_len = -1;
  }

  apr_pool_create(&pool, NULL);

  if ((status = htt_sockio_new(&sockio, worker->socket->socket,
#ifdef USE_SSL
                               worker->socket->is_ssl ? worker->socket->ssl : NULL,
#endif
                               pool)) != APR_SUCCESS) {
    goto out_err;
  }

  headers = apr_table_make(pool, 10);

  while (htt_sockio_read_line(sockio, &line) == APR_SUCCESS) {
    htt_worker_log(worker, HTT_LOG_INFO, "<%s", line);
    if (line[0] == 0) {
      /* if recv len is specified use this */
      if (recv_len != -1) {
        if ((status =
             htt_ct_len_reader(sockio, &buf, &len, val)) != APR_SUCCESS) {
	  break;
	}
      }
      /* else get transfer type */
      else if ((val = apr_table_get(headers, "Content-Length"))) {
        len = apr_atoi64(val);
        if ((status =
             htt_ct_len_reader(sockio, &buf, &len, val)) != APR_SUCCESS) {
          break;
        }
      }
      else if ((val = apr_table_get(headers, "Transfer-Encoding"))) {
	if ((status =
	     htt_trans_enc_reader(sockio, &buf, &len, val)) != APR_SUCCESS) {
	  break;
	}
      }
      else if ((val = apr_table_get(headers, "Encapsulated"))) {
        if ((status = htt_encap_reader(sockio, &buf, &len, val)) != APR_SUCCESS) {
          break;
        }
      }
      else if ((val = apr_table_get(headers, "Connection"))) {
        if ((status = htt_eof_reader(sockio, &buf, &len, val)) != APR_SUCCESS) {
          break;
        }
      }
      if (buf) {
        htt_worker_log_buf(worker, HTT_LOG_INFO, buf, "<", len);
        htt_worker_match(worker, worker->match_body, buf);
        htt_worker_expect(worker, worker->expect_dot, buf);
	if (worker->flags & HTT_FLAGS_PIPE_IN) {
	  worker->flags &= ~HTT_FLAGS_PIPE_IN;
	  inlen = len;
	  if ((status = apr_file_write(worker->proc.in, buf, &inlen))
	      != APR_SUCCESS) {
	    goto out_err;
	  }
	  apr_file_close(worker->proc.in);
          apr_proc_wait(&worker->proc, &exitcode, &exitwhy, APR_WAIT);
          if (exitcode != 0) {
	    status = APR_EGENERAL;
	    goto out_err;
          }
	}
      }
      break;
    }
    else {
      /* before splitting do a match */
      htt_worker_match(worker, worker->match_headers, line);
      htt_worker_expect(worker, worker->expect_dot, line);

      /* headers */
      key = apr_strtok(line, ":", &last);
      val = apr_strtok(NULL, ":", &last);
      if (i > 0 && worker->headers_allow) {
	if (!apr_table_get(worker->headers_allow, key)) {
	  htt_worker_log(worker, HTT_LOG_ERR, "%s header not allowed", key);
	  status = APR_EGENERAL;
	  goto out_err;
	}
      }
      if (i > 0 && worker->headers_filter) {
	if (!apr_table_get(worker->headers_filter, key)) {
          apr_table_add(headers, key, val);
	}
      }
      else {
        apr_table_add(headers, key, val);
      }
    }
    ++i;
  }

out_err:
  status = htt_worker_check_expect(worker, status);

  apr_pool_destroy(pool);
  return status;
}

/****
 * Scriptable commands 
 ****/

/**
 * Get socket from hash or add a new one
 *
 * @param self IN thread data object
 * @param hostname IN host name
 * @param portname IN port as ascii string
 *
 */
static void htt_worker_get_socket(htt_worker_t *self, const char *hostname, 
                              const char *portname, const char *tag) {
  htt_socket_t *socket;

  socket = 
    apr_hash_get(self->sockets, apr_pstrcat(self->ptmp, hostname, portname, 
	                                    tag, NULL),
	         APR_HASH_KEY_STRING);

  if (!socket) {
    socket = apr_pcalloc(self->pool, sizeof(*socket));
    socket->socket_state = HTT_SOCK_CLOSED;
    apr_hash_set(self->sockets, apr_pstrcat(self->pool, hostname, portname,
	                                    tag, NULL),
	         APR_HASH_KEY_STRING, socket);
  }

  self->socket = socket;
}

/**
 * Setup a connection to host
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN aditional data
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_REQ(htt_cmd_t * self, htt_worker_t * worker,
                                char *data) {
  apr_status_t status;
  apr_sockaddr_t *remote_addr;
  char *portname;
  char *hostname;
  char *filename;
  char *tag;
  char *last;
  int port;
  char *copy;
  int is_ssl;

  if ((status = htt_worker_flush(worker)) != APR_SUCCESS) {
    return status;
  }

  if ((status = htt_worker_test_unused(worker)) != APR_SUCCESS) {
    return status;
  }

  HTT_CMD_NEED_ARG("Need hostname and port");

  hostname = apr_strtok(copy, " ", &last);
  portname = apr_strtok(NULL, " ", &last);

  if (!hostname) {
    htt_worker_log(worker, HTT_LOG_ERR, "no host name specified");
    return APR_EGENERAL;
  }
  
  if (!portname) {
    htt_worker_log(worker, HTT_LOG_ERR, "no portname name specified");
    return APR_EGENERAL;
  }

#ifdef USE_SSL
  is_ssl = 0;
  if (strncmp(portname, "SSL:", 4) == 0) {
    is_ssl = 1;
    worker->meth = SSLv23_client_method();
    portname += 4;
  }
  else if (strncmp(portname, "SSL2:", 4) == 0) {
    is_ssl = 1;
    worker->meth = SSLv2_client_method();
    portname += 5;
  }
  else if (strncmp(portname, "SSL3:", 4) == 0) {
    is_ssl = 1;
    worker->meth = SSLv3_client_method();
    portname += 5;
  }
  else if (strncmp(portname, "TLS1:", 4) == 0) {
    is_ssl = 1;
    worker->meth = TLSv1_client_method();
    portname += 5;
  }
  
  if (!portname[0]) {
    htt_worker_log(worker, HTT_LOG_ERR, "no SSL port specified");
    return APR_EGENERAL;
  }
#endif
  portname = apr_strtok(portname, ":", &tag);
  port = apr_atoi64(portname);

  htt_worker_get_socket(worker, hostname, portname, tag);
  
  worker->socket->is_ssl = is_ssl;

  if (worker->socket->socket_state == HTT_SOCK_CLOSED) {
#ifdef USE_SSL
    if (worker->socket->is_ssl) {
      if (!worker->ssl_ctx && !(worker->ssl_ctx = SSL_CTX_new(worker->meth))) {
        htt_worker_log(worker, HTT_LOG_ERR, "Could not initialize SSL Context.");
      }
      SSL_CTX_set_options(worker->ssl_ctx, SSL_OP_ALL);
      SSL_CTX_set_options(worker->ssl_ctx, SSL_OP_SINGLE_DH_USE);
      /* get cert file if any is specified */
      filename = apr_strtok(NULL, " ", &last);
      if (filename && SSL_CTX_use_certificate_file(worker->ssl_ctx, filename, 
				       SSL_FILETYPE_PEM) <= 0) { 
	htt_worker_log(worker, HTT_LOG_ERR, "Could not load RSA certifacte \"%s\"", 
	           filename);
	return APR_EINVAL;
      }

      /* get key file if any is specified */
      filename = apr_strtok(NULL, " ", &last);
      if (filename && SSL_CTX_use_PrivateKey_file(worker->ssl_ctx, filename, 
	                              SSL_FILETYPE_PEM) <= 0) {
	htt_worker_log(worker, HTT_LOG_ERR, "Could not load RSA private key \"%s\"", 
	           filename);
	return APR_EINVAL;
      }

      /* get ca file if any is specified */
      filename = apr_strtok(NULL, " ", &last);
      if (filename && !SSL_CTX_load_verify_locations(worker->ssl_ctx, filename,
	                                             NULL)) {
	htt_worker_log(worker, HTT_LOG_ERR, "Could not load CA file \"%s\"", filename);
	return APR_EINVAL;
      }
#if (OPENSSL_VERSION_NUMBER < 0x00905100L)
      SSL_CTX_set_verify_depth(worker->ssl_ctx,1);
#endif

    }
#endif

    if ((status = apr_socket_create(&worker->socket->socket, APR_INET, 
	                            SOCK_STREAM, APR_PROTO_TCP,
                                    worker->pool)) != APR_SUCCESS) {
      worker->socket->socket = NULL;
      return status;
    }

    if ((status =
         apr_socket_opt_set(worker->socket->socket, APR_TCP_NODELAY,
                            1)) != APR_SUCCESS) {
      return status;
    }

    if ((status =
         apr_socket_timeout_set(worker->socket->socket, worker->socktmo)) != APR_SUCCESS) {
      return status;
    }

#ifdef USE_SSL
    if (worker->socket->is_ssl) {
      BIO *bio;
      apr_os_sock_t fd;

      if ((worker->socket->ssl = SSL_new(worker->ssl_ctx)) == NULL) {
        htt_worker_log(worker, HTT_LOG_ERR, "SSL_new failed.");
        status = APR_ECONNREFUSED;
      }
      SSL_set_ssl_method(worker->socket->ssl, worker->meth);
      htt_ssl_seed();
      apr_os_sock_get(&fd, worker->socket->socket);
      bio = BIO_new_socket(fd, BIO_NOCLOSE);
      SSL_set_bio(worker->socket->ssl, bio, bio);
      SSL_set_connect_state(worker->socket->ssl);
    }
#endif

    if ((status =
         apr_sockaddr_info_get(&remote_addr, hostname, AF_UNSPEC, port,
                               APR_IPV4_ADDR_OK, worker->pool))
        != APR_SUCCESS) {
      return status;
    }

    if ((status =
         apr_socket_connect(worker->socket->socket, remote_addr)) 
	!= APR_SUCCESS) {
      return status;
    }

    if ((status =
         apr_socket_opt_set(worker->socket->socket, APR_SO_KEEPALIVE,
                            1)) != APR_SUCCESS) {
      return status;
    }

    worker->socket->socket_state = HTT_SOCK_CONNECTED;
#ifdef USE_SSL
    if (worker->socket->is_ssl) {
      if ((status = htt_worker_ssl_handshake(worker)) != APR_SUCCESS) {
	return status;
      }
    }
#endif
  }

  /* reset the matcher tables */
  apr_table_clear(worker->match_headers);
  apr_table_clear(worker->match_body);
  apr_table_clear(worker->expect_dot);
  apr_table_clear(worker->expect_error);
  apr_table_clear(worker->match_error);

  return APR_SUCCESS;
}

/**
 * Setup a connection to host
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN unused 
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_RES(htt_cmd_t * self, htt_worker_t * worker,
                                char *data) {
  apr_status_t status;

  HTT_CMD_NO_ARG;

  if ((status = htt_worker_flush(worker)) != APR_SUCCESS) {
    return status;
  }

  if ((status = htt_worker_test_unused(worker)) != APR_SUCCESS) {
    return status;
  }

  htt_worker_get_socket(worker, "Default", "0", NULL);
  worker->socket->is_ssl = worker->is_ssl;

  if (worker->socket->socket_state == HTT_SOCK_CLOSED) {
    htt_worker_log(worker, HTT_LOG_DEBUG, "--- accept");
    if (!worker->listener) {
      htt_worker_log_error(worker, "Server down");
      return APR_EGENERAL;
    }

    if ((status =
         apr_socket_accept(&worker->socket->socket, worker->listener,
                           worker->pool)) != APR_SUCCESS) {
      worker->socket->socket = NULL;
      return status;
    }
    if ((status =
           apr_socket_timeout_set(worker->socket->socket, worker->socktmo)) 
	!= APR_SUCCESS) {
      return status;
    }
#ifdef USE_SSL
    if ((status = htt_worker_ssl_accept(worker)) != APR_SUCCESS) {
      return status;
    }
#endif
    worker->socket->socket_state = HTT_SOCK_CONNECTED;
  }

  apr_table_clear(worker->match_headers);
  apr_table_clear(worker->match_body);
  apr_table_clear(worker->expect_dot);
  apr_table_clear(worker->expect_error);
  apr_table_clear(worker->match_error);

  return APR_SUCCESS;
}

/**
 * Sleep for a given time (ms)
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN time to wait in ms
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_SLEEP(htt_cmd_t * self, htt_worker_t * worker,
                                  char *data) {
  apr_status_t status;
  char *copy;

  if ((status = htt_worker_flush(worker)) != APR_SUCCESS) {
    return status;
  }

  HTT_CMD_NEED_ARG("Time not specified");
 
  apr_sleep(apr_atoi64(copy) * 1000);
  return APR_SUCCESS;
}

/**
 * Define an expect
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN "%s %s" type match 
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_EXPECT(htt_cmd_t * self, htt_worker_t * worker,
                                   char *data) {
  char *last;
  char *type;
  char *match;
  htt_regex_t *compiled;
  const char *err;
  int off;
  char *copy;
  char *interm;

  HTT_CMD_NEED_ARG("Type and regex not specified");

  type = apr_strtok(copy, " ", &last);
  
  match = htt_unescape(last, &last);

  if (!type) {
    htt_worker_log(worker, HTT_LOG_ERR, "Type not specified");
    return APR_EGENERAL;
  }
  
  if (!match) {
    htt_worker_log(worker, HTT_LOG_ERR, "Regex not specified");
    return APR_EGENERAL;
  }

  interm = apr_pstrdup(worker->ptmp, match);

  if (interm[0] == '!') {
    ++interm;
  }

  if (!(compiled = htt_pregcomp(worker->ptmp, interm, &err, &off))) {
    htt_worker_log(worker, HTT_LOG_ERR, "EXPECT regcomp failed: \"%s\"", last);
    return APR_EINVAL;
  }

  if (strcmp(type, ".") == 0) {
    apr_table_addn(worker->expect_dot, match, (char *) compiled);
  }
  else if (strcmp(type, "ERROR") == 0) {
    apr_table_addn(worker->expect_error, match, (char *) compiled);
  }
  else {
    htt_worker_log(worker, HTT_LOG_ERR, "EXPECT type \"%s\" unknown", type);
    return APR_EINVAL;
  }

  return APR_SUCCESS;
}

/**
 * Close socket
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN unused
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_CLOSE(htt_cmd_t * self, htt_worker_t * worker,
                                  char *data) {
  apr_status_t status;

  HTT_CMD_NO_ARG;

  if ((status = htt_worker_flush(worker)) != APR_SUCCESS) {
    htt_worker_conn_close(worker);
    return status;
  }

  if ((status = htt_worker_test_unused(worker)) != APR_SUCCESS) {
    htt_worker_conn_close(worker);
    return status;
  }

  if ((status = htt_worker_conn_close(worker)) != APR_SUCCESS) {
    return status;
  }

  return APR_SUCCESS;
}

/**
 * Specify a timeout for socket operations (ms) 
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN time in ms 
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_TIMEOUT(htt_cmd_t * self, htt_worker_t * worker,
                                    char *data) {
  apr_time_t tmo;
  char *copy;

  HTT_CMD_NEED_ARG("Time not specified");

  tmo = apr_atoi64(copy);
  worker->socktmo = tmo * 1000;

  return APR_SUCCESS;
}

/**
 * Define an expect
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN "%s %s %s" type match variable
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_MATCH(htt_cmd_t * self, htt_worker_t * worker,
                                  char *data) {
  char *last;
  char *type;
  char *match;
  char *vars;
  htt_regex_t *compiled;
  const char *err;
  int off;
  char *copy;

  HTT_CMD_NEED_ARG("Type, regex and variable not specified");

  type = apr_strtok(copy, " ", &last);
  
  match = htt_unescape(last, &last);
  
  vars = apr_strtok(NULL, "", &last);

  if (!type) {
    htt_worker_log(worker, HTT_LOG_ERR, "Type not specified");
    return APR_EGENERAL;
  }

  if (!match) {
    htt_worker_log(worker, HTT_LOG_ERR, "Regex not specified");
    return APR_EGENERAL;
  }

  if (!vars) {
    htt_worker_log(worker, HTT_LOG_ERR, "Variable not specified");
    return APR_EGENERAL;
  }

  if (vars) {
    ++vars;
    //apr_collapse_spaces(vars, vars);
  }

  if (!vars) {
    return APR_EINVAL;
  }

  if (!(compiled = htt_pregcomp(worker->ptmp, match, &err, &off))) {
    htt_worker_log(worker, HTT_LOG_ERR, "MATCH regcomp failed: %s", last);
    return APR_EINVAL;
  }
  if (strcasecmp(type, "Headers") == 0) {
    apr_table_addn(worker->match_headers, vars, (char *) compiled);
  }
  else if (strcasecmp(type, "Body") == 0) {
    apr_table_addn(worker->match_body, vars, (char *) compiled);
  }
  else if (strcasecmp(type, "ERROR") == 0) {
    apr_table_addn(worker->match_error, vars, (char *) compiled);
  }
  else {
    htt_worker_log(worker, HTT_LOG_ERR, "Match type %s do not exist", type);
    return APR_ENOENT;
  }

  return APR_SUCCESS;
}

/**
 * set command
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN key=value 
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_SET(htt_cmd_t * self, htt_worker_t * worker,
                                char *data) {
  char *vars_last;
  const char *vars_key;
  const char *vars_val;
  char *copy;

  HTT_CMD_NEED_ARG("Variable and value not specified");
  
  vars_key = apr_strtok(copy, "=", &vars_last);
  vars_val = apr_strtok(NULL, "", &vars_last);

  if (!vars_key) {
    htt_worker_log(worker, HTT_LOG_ERR, "Key not specified");
    return APR_EGENERAL;
  }

  if (!vars_val) {
    htt_worker_log(worker, HTT_LOG_ERR, "Value not specified");
    return APR_EGENERAL;
  }
  
  apr_table_set(worker->vars, vars_key, vars_val);

  return APR_SUCCESS;
}

/**
 * If statement (not implemented yet)
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN expression 
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_IF(htt_cmd_t * self, htt_worker_t * worker,
                               char *data) {
  char *copy;
  char *left;
  char *right;
  char *middle;
  char *last;
  const char *err;
  int off;
  int not;
  htt_regex_t *compiled;
  apr_status_t status;
  htt_worker_t *body;

 
  HTT_CMD_NEED_ARG("Need left operant right parameters");
  
  ++copy;
  left = apr_strtok(copy, "\"", &last);
  middle = apr_strtok(NULL, " ", &last);
  right = apr_strtok(NULL, "\"", &last);
 
  if (!left || !middle || !right) {
    htt_worker_log(worker, HTT_LOG_ERR, "%s: Syntax error '%s'", self->name, data);
    return APR_EGENERAL;
  }
  
  if (right[0] == '!') {
    not = 1;
    ++right;
  }
  else {
    not = 0;
  }
 
  if (strcmp(middle, "MATCH") == 0) {
    if (!(compiled = htt_pregcomp(worker->ptmp, right, &err, &off))) {
      htt_worker_log(worker, HTT_LOG_ERR, "IF MATCH regcomp failed: %s", right);
      return APR_EINVAL;
    }
  }
  else {
    return APR_ENOTIMPL;
  }

  if ((status = htt_worker_body(&body, worker, "IF")) != APR_SUCCESS) {
    return status;
  }

  if ((htt_regexec(compiled, left, 0, NULL, PCRE_MULTILINE) == 0 && !not) ||
      (htt_regexec(compiled, left, 0, NULL, PCRE_MULTILINE) != 0 && not)) {
    status = htt_worker_interpret(body, worker);
  }

  htt_worker_log(worker, HTT_LOG_INFO, "_END IF");

  htt_worker_body_end(body, worker);
 
  return status;
}

/**
 * Send data 
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN data to send
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_DATA(htt_cmd_t * self, htt_worker_t * worker,
                                 char *data) {
  char *copy;

  if (!worker->socket || !worker->socket->socket) {
    return APR_ENOSOCKET;
  }
    
  copy = apr_pstrdup(worker->ptmp, data); 
  copy = htt_worker_replace_vars(worker, copy);
  htt_worker_log(worker, HTT_LOG_INFO, "%s%s", self->name, copy); 

  if (strncasecmp(copy, "Content-Length: AUTO", 20) == 0) {
    apr_table_add(worker->cache, "Content-Length", "Content-Length");
  }
  else {
    apr_table_addn(worker->cache, "TRUE", copy);
  }

  return APR_SUCCESS;
}

/**
 * Flush data 
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN unused
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_FLUSH(htt_cmd_t * self, htt_worker_t * worker,
                                  char *data) {
  apr_status_t status;

  HTT_CMD_NO_ARG;

  if ((status = htt_worker_flush(worker)) != APR_SUCCESS) {
    return status;
  }

  return APR_SUCCESS;
}

/**
 * Chunk info 
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN unused
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_CHUNK(htt_cmd_t * self, htt_worker_t * worker,
                                  char *data) {
  apr_status_t status;

  HTT_CMD_NO_ARG;

  apr_table_add(worker->cache, "CHUNKED", "CHUNKED");

  if ((status = htt_worker_flush(worker)) != APR_SUCCESS) {
    return status;
  }

  return APR_SUCCESS;
}

/**
 * read from file descriptor and write it to the HTTP stream
 * 
 * @param worker IN thread data object
 * @param file IN open file descriptor for reading
 * @param flags IN HTT_FLAGS_CHUNKED or HTT_FLAGS_NONE
 *
 * @return APR_SUCCESS or an apr error status
 */
static apr_status_t htt_worker_file_to_http(htt_worker_t *self, apr_file_t *file, int flags) {
  apr_status_t status;
  apr_size_t len;
  char *buf;

  while (1) {
    if (flags & HTT_FLAGS_CHUNKED) {
      len = self->chunksize;
    }
    else {
      len = HTT_BLOCK_MAX;
    }
    buf = apr_pcalloc(self->ptmp, len + 1);
    if ((status = apr_file_read(file, buf, &len)) != APR_SUCCESS) {
      break;
    }
    apr_table_addn(self->cache, 
		   apr_psprintf(self->ptmp, "NOCRLF:%d", len), buf);
    if (flags & HTT_FLAGS_CHUNKED) {
      htt_worker_log(self, HTT_LOG_DEBUG, "--- chunk size: %d", len);
      apr_table_add(self->cache, "CHUNKED", "CHUNKED");
      if ((status = htt_worker_flush(self)) != APR_SUCCESS) {
	return status;
      }
    }
  }

  if (APR_STATUS_IS_EOF(status)) {
    return APR_SUCCESS;
  }
  else {
    return status;
  }
}

/**
 * Execute an external program 
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN external program call with arguments 
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_EXEC(htt_cmd_t * self, htt_worker_t * worker,
                                 char *data) {
  char *copy;
  apr_status_t status;
  apr_procattr_t *attr;
  apr_table_t *table;
  apr_table_entry_t *e;
  const char *progname;
  const char **args;
  apr_exit_why_e exitwhy;
  int exitcode;
  char *last;
  char *val;
  int i;
  int flags;

  HTT_CMD_NEED_ARG("Need a shell command");

  flags = worker->flags;
  worker->flags &= ~HTT_FLAGS_PIPE;
  worker->flags &= ~HTT_FLAGS_CHUNKED;
  worker->flags &= ~HTT_FLAGS_PIPE_IN;
  if (copy[0] == '|') {
    ++copy;
    worker->flags |= HTT_FLAGS_PIPE_IN;
  }
  
  table = apr_table_make(worker->ptmp, 5);
  progname = apr_strtok(copy, " ", &last);

  if (!progname) {
    htt_worker_log(worker, HTT_LOG_ERR, "No program name specified");
    return APR_EGENERAL;
  }
  
  apr_table_addn(table, progname, "TRUE");

  while ((val = apr_strtok(NULL, " ", &last))) {
    apr_table_addn(table, val, "TRUE");
  }

  args = apr_pcalloc(worker->ptmp,
                     (apr_table_elts(table)->nelts + 1) * sizeof(const char *));

  e = (apr_table_entry_t *) apr_table_elts(table)->elts;
  for (i = 0; i < apr_table_elts(table)->nelts; i++) {
    args[i] = e[i].key;
  }
  args[i] = NULL;

  if ((status = apr_procattr_create(&attr, worker->ptmp)) != APR_SUCCESS) {
    return status;
  }

  if ((status = apr_procattr_cmdtype_set(attr, APR_SHELLCMD)) != APR_SUCCESS) {
    return status;
  }

  if (flags & HTT_FLAGS_PIPE) {
    if ((status = apr_procattr_io_set(attr,  APR_NO_PIPE, APR_FULL_BLOCK,
				      APR_NO_PIPE))
	!= APR_SUCCESS) {
      return status;
    }
  }

  if (worker->flags & HTT_FLAGS_PIPE_IN) {
    if ((status = apr_procattr_io_set(attr, APR_FULL_BLOCK, APR_NO_PIPE,
				      APR_NO_PIPE))
	!= APR_SUCCESS) {
      return status;
    }
  }

  if ((status = apr_proc_create(&worker->proc, progname, args, NULL, attr,
                                worker->ptmp)) != APR_SUCCESS) {
    return status;
  }

  if (flags & HTT_FLAGS_PIPE) {
    if ((status = htt_worker_file_to_http(worker, worker->proc.out, flags)) != APR_SUCCESS) {
      return status;
    }
  }
  
  if (!(worker->flags & HTT_FLAGS_PIPE_IN)) {
    apr_proc_wait(&worker->proc, &exitcode, &exitwhy, APR_WAIT);

    if (worker->flags & HTT_FLAGS_PIPE) {
      apr_file_close(worker->proc.out);
    }

    if (exitcode != 0) {
      return APR_EGENERAL;
    }
  }

  return APR_SUCCESS;
}

/**
 * Send file
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN file
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_SENDFILE(htt_cmd_t * self, htt_worker_t * worker,
                                     char *data) {
  char *copy;
  char *last;
  char *filename;
  apr_status_t status;
  int flags;
  apr_file_t *fp;

  HTT_CMD_NEED_ARG("Need a file name");

  filename = apr_strtok(copy, " ", &last);

  flags = worker->flags;
  worker->flags &= ~HTT_FLAGS_PIPE;
  worker->flags &= ~HTT_FLAGS_CHUNKED;
  
  if ((status =
       apr_file_open(&fp, filename, APR_READ, APR_OS_DEFAULT,
		     worker->ptmp)) != APR_SUCCESS) {
    fprintf(stderr, "\nCan not send file: File \"%s\" not found", copy);
    return APR_ENOENT;
  }
  
  if (flags & HTT_FLAGS_PIPE) {
    if ((status = htt_worker_file_to_http(worker, fp, flags)) != APR_SUCCESS) {
      return status;
    }
  }

  return APR_SUCCESS;
}

/**
 * Declare a pipe
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN not used
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_PIPE(htt_cmd_t * self, htt_worker_t * worker,
                                 char *data) {
  char *copy;
  char *last;
  char *add;
  char *val;

  HTT_CMD_OPTIONAL_ARG;

  add = apr_strtok(copy, " ", &last);
  if (add) {
    val = apr_strtok(NULL, " ", &last);
  }
  else {
    val = NULL;
  }
  
  htt_worker_log(worker, HTT_LOG_DEBUG, "additional: %s, value: %s", add, val);
  
  if (add && strncasecmp(add, "chunked", 7) == 0) {
    worker->chunksize = val ? apr_atoi64(val) : HTT_BLOCK_MAX;
    worker->flags |= HTT_FLAGS_CHUNKED;
  }
  
  worker->flags |= HTT_FLAGS_PIPE;

  return APR_SUCCESS;
}

/**
 * Send data without a CRLF
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN data to send
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_NOCRLF(htt_cmd_t * self, htt_worker_t * worker,
                                   char *data) {
  char *copy;

  copy = apr_pstrdup(worker->ptmp, data); 
  copy = htt_worker_replace_vars(worker, copy);
  htt_worker_log(worker, HTT_LOG_INFO, "%s%s", self->name, copy); 

  apr_table_addn(worker->cache, "NOCRLF", copy);

  return APR_SUCCESS;
}

/**
 * Send data without a CRLF
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN data to send
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_SOCKSTATE(htt_cmd_t * self, htt_worker_t * worker,
                                      char *data) {
  char *copy;

  HTT_CMD_NEED_ARG("Need a variable name");

  if (htt_worker_sockstate(worker) == APR_SUCCESS) {
    apr_table_set(worker->vars, copy, "CONNECTED");
  }
  else {
    apr_table_set(worker->vars, copy, "CLOSED");
  }

  return APR_SUCCESS;
}

/**
 * Ignores errors specified.
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN regex 
 *
 * @return an apr status
 */
static apr_status_t htt_cmd_IGNORE_ERR(htt_cmd_t * self, htt_worker_t * worker,
                                       char *data) {
  char *copy;

  HTT_CMD_NEED_ARG("Need a regex");

  /* TODO: only .* is implemented */
  worker->flags |= HTT_FLAGS_IGNORE_ERRORS;
  
  return APR_SUCCESS;
}

/**
 * Exit program with OK|FAILED 
 *
 * @param self IN command object
 * @param worker IN thread data object
 * @param data IN OK|FAILED|<empty> 
 *
 * @return never reached
 */
static apr_status_t htt_cmd_EXIT(htt_cmd_t * self, htt_worker_t * worker, 
                                 char *data) {
  char *copy;

  HTT_CMD_OPTIONAL_ARG;

  if (strcmp(copy, "OK") == 0) {
    htt_worker_destroy(worker);
    exit(0);
  }
  else {
    htt_worker_set_global_error(worker);
    htt_worker_destroy(worker);
    exit(-1);
  }

  /* just make the compiler happy, never reach this point */
  return APR_SUCCESS;
}

/**
 * HEADER command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN header name (spaces are possible) 
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_HEADER(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;
  char *method;
  char *header;
  char *last;

  HTT_CMD_NEED_ARG("Need method ALLOW or FILTER and a header name");

  method = apr_strtok(copy, " ", &last);
  header = apr_strtok(NULL, " ", &last);
  
  if (strcasecmp(method, "ALLOW") == 0) {
    if (!worker->headers_allow) {
      worker->headers_allow = apr_table_make(worker->pool, 10);
    }
    apr_table_add(worker->headers_allow, header, method);
  }
  else if (strcasecmp(method, "FILTER") == 0) {
    if (!worker->headers_filter) {
      worker->headers_filter = apr_table_make(worker->pool, 5);
    }
    apr_table_add(worker->headers_filter, header, method);
  }
  else {
    return APR_ENOTIMPL;
  }

  return APR_SUCCESS;
}

/**
 * LOOP command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN header name (spaces are possible) 
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_LOOP(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  apr_status_t status;
  htt_worker_t *body;
  char *copy;
  int loop;
  int i;

  HTT_CMD_NEED_ARG("Need a number"); 
 
  if (strncmp(copy, "FOREVER", 7) == 0) {
    loop = -1;
  }
  else {
    loop = apr_atoi64(copy);
  }
  
  /* create a new worker body */
  if ((status = htt_worker_body(&body, worker, "LOOP")) != APR_SUCCESS) {
    return status;
  }
  
  /* loop */
  for (i = 0; loop == -1 || i < loop; i++) {
    /* interpret */
    if ((status = htt_worker_interpret(body, worker)) != APR_SUCCESS) {
      break;
    }
  }
  
  htt_worker_log(worker, HTT_LOG_INFO, "_END LOOP");
  
  htt_worker_body_end(body, worker);
  
  return status;
}

/**
 * RAND command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN header name (spaces are possible) 
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_RAND(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;
  char *val;
  char *last;
  int start;
  int end;
  int result;

  HTT_CMD_NEED_ARG("Need a start and end number and a variable"); 
  
  val = apr_strtok(copy, " ", &last);
  start = apr_atoi64(val);
  val = apr_strtok(NULL, " ", &last);
  end = apr_atoi64(val);
  val = apr_strtok(NULL, " ", &last);

  if (val == NULL) {
    htt_worker_log(worker, HTT_LOG_ERR, "No variable name specified");
    return APR_EINVAL;
  }
  
  result = start + (rand() % (end - start)); 

  apr_table_set(worker->vars, val, apr_itoa(worker->ptmp, result));

  return APR_SUCCESS;
}

/**
 * DEBUG command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN string to print on stderr
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_DEBUG(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;
  
  HTT_CMD_OPTIONAL_ARG;

  htt_worker_log(worker, HTT_LOG_ERR, "%s", copy);

  return APR_SUCCESS;
}

/**
 * Setup listener
 *
 * @param worker IN thread data object
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_worker_listener_up(htt_worker_t *worker) {
  apr_sockaddr_t *local_addr;

  apr_status_t status = APR_SUCCESS;

  htt_worker_get_socket(worker, "Default", "0", NULL);
  
  if (worker->listener) {
    htt_worker_log_error(worker, "Server allready up");
    return APR_EGENERAL;
  }
  
  if ((status = apr_sockaddr_info_get(&local_addr, APR_ANYADDR, APR_UNSPEC,
                                      worker->listener_port, APR_IPV4_ADDR_OK, worker->pool))
      != APR_SUCCESS) {
    goto error;
  }

  if ((status = apr_socket_create(&worker->listener, APR_INET, SOCK_STREAM,
                                  APR_PROTO_TCP, worker->pool)) != APR_SUCCESS)
  {
    worker->listener = NULL;
    goto error;
  }

  status = apr_socket_opt_set(worker->listener, APR_SO_REUSEADDR, 1);
  if (status != APR_SUCCESS && status != APR_ENOTIMPL) {
    goto error;
  }
  
  htt_worker_log(worker, HTT_LOG_DEBUG, "--- bind");
  if ((status = apr_socket_bind(worker->listener, local_addr)) != APR_SUCCESS) {
    goto error;
  }

  htt_worker_log(worker, HTT_LOG_DEBUG, "--- listen");
  if ((status = apr_socket_listen(worker->listener, HTT_BACKLOG_DEFAULT)) != APR_SUCCESS) {
    goto error;
  }

  worker->socket->socket_state = HTT_SOCK_CLOSED;

error:
  return status;
}

/**
 * UP command bind a listener socket
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN unused
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_UP(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  HTT_CMD_NO_ARG;

  return htt_worker_listener_up(worker);
}

/**
 * DOWN command shuts down listener
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN unused
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_DOWN(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  apr_status_t status;

  HTT_CMD_NO_ARG;

  if (!worker->listener) {
    htt_worker_log_error(worker, "Server allready down", self->name);
    return APR_EGENERAL;
  }
  
  if ((status = apr_socket_close(worker->listener)) != APR_SUCCESS) {
    return status;
  }
  worker->listener = NULL;
  return status;
}

/**
 * TIME command stores time in a variable [ms]
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN variable name 
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_TIME(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;

  HTT_CMD_NEED_ARG("Need a variable name to store time");
  
  apr_table_set(worker->vars, copy, apr_psprintf(worker->ptmp, "%llu", apr_time_as_msec(apr_time_now())));

  return APR_SUCCESS;
}

/**
 * CALL command calls a defined block
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN name of calling block 
 *
 * @return block status or APR_EINVAL 
 */
static apr_status_t htt_cmd_CALL(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  apr_status_t status;
  apr_status_t mutex_status;
  char *copy;
  char *block_name;
  char *last;
  htt_worker_t *block, *call;
  apr_table_t *lines;
  int cmd;
  apr_pool_t *call_pool;

  HTT_CMD_NEED_ARG("Need a block name: <block> (<name> => <value>)*");

  block_name = apr_strtok(copy, " ", &last);

  /* CR BEGIN */
  if ((mutex_status = apr_thread_mutex_lock(worker->sync_mutex)) != APR_SUCCESS) {
    return mutex_status;
  }
  if (!(block = apr_hash_get(worker->blocks, block_name, APR_HASH_KEY_STRING))) {
    htt_worker_log_error(worker, "Could not find block %s", block_name);
    /* CR END */
    if ((mutex_status = apr_thread_mutex_unlock(worker->sync_mutex)) != APR_SUCCESS) {
      return mutex_status;
    }
    return APR_EINVAL;
  }
  else { 
    apr_pool_create(&call_pool, worker->ptmp);
    lines = htt_table_deep_copy(call_pool, block->lines);
    if ((mutex_status = apr_thread_mutex_unlock(worker->sync_mutex)) != APR_SUCCESS) {
      return mutex_status;
    }
    /* CR END */
    call = apr_pcalloc(call_pool, sizeof(htt_worker_t));
    memcpy(call, worker, sizeof(htt_worker_t));
    /* lines in block */
    call->lines = lines;
    status = htt_worker_interpret(call, worker);
    cmd = worker->cmd;
    lines = worker->lines;
    memcpy(worker, call, sizeof(htt_worker_t));
    worker->lines = lines;
    worker->cmd = cmd;

    return status;
  }
}

/**
 * HTT_LOG_LEVEL command sets log level 
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN number 0-4 
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_LOG_LEVEL(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;

  HTT_CMD_NEED_ARG("Need a number between 0 and 4");

  worker->log_mode = apr_atoi64(copy);

  return APR_SUCCESS;
}

/**
 * SYNC command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN unused
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_SYNC(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  apr_time_t sec;
  apr_time_t nxt_sec;
  apr_time_t now;

  HTT_CMD_NO_ARG;

  /* get current time */
  now = apr_time_now();
  /* get next second */
  sec = apr_time_sec(now) + 1;
  /* next second in us */
  nxt_sec = apr_time_from_sec(sec);
  /* sleep until next sec */
  apr_sleep(nxt_sec - now);
  
  return APR_SUCCESS;
}

/**
 * RECV command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN unused
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_cmd_RECV(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;
  apr_pool_t *pool;
  apr_status_t status;
  apr_size_t recv_len;
  htt_sockio_t *sockio;
  char *buf;
  char *last;
  char *val;

  HTT_CMD_NEED_ARG("Need a number or POLL");

  /* get first value, can be either POLL or a number */
  val = apr_strtok(copy, " ", &last);
  if (strcmp(val, "POLL") == 0) {
    /* recv_len to max and timeout to min */
    recv_len = HTT_BLOCK_MAX;
    /* set timout to specified socket tmo */
    if ((status =
           apr_socket_timeout_set(worker->socket->socket, worker->socktmo)) 
	!= APR_SUCCESS) {
      return status;
    }
  }
  else {
    /* must be a number */
    recv_len = apr_atoi64(val);
  }

  apr_pool_create(&pool, NULL);

  if ((status = htt_sockio_new(&sockio, worker->socket->socket,
#ifdef USE_SSL
                               worker->socket->is_ssl ? worker->socket->ssl : NULL,
#endif
                               pool)) != APR_SUCCESS) {
    goto out_err;
  }

  if ((status = htt_ct_len_reader(sockio, &buf, &recv_len, "")) != APR_SUCCESS) {
    goto out_err;
  }

  if (buf) {
    htt_worker_log_buf(worker, HTT_LOG_INFO, buf, "<", recv_len);
    htt_worker_match(worker, worker->match_body, buf);
    htt_worker_expect(worker, worker->expect_dot, buf);
  }

out_err:
  status = htt_worker_check_expect(worker, status);
  apr_pool_destroy(pool);

  return status;
}

/**
 * OP command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN left op right var
 *
 * @return APR_SUCCESS or apr error code
 */
static apr_status_t htt_cmd_OP(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;
  char *last;
  char *left;
  char *op;
  char *right;
  char *var;
  int ileft;
  int iright;
  int result;

  HTT_CMD_NEED_ARG("<left> ADD|SUB|MUL|DIV <right> <variable> expected");

  /* split into left, op, right, var */
  left = apr_strtok(copy, " ", &last);
  op = apr_strtok(NULL, " ", &last);
  right = apr_strtok(NULL, " ", &last);
  var = apr_strtok(NULL, " ", &last);

  /* do checks */
  if (!left || !op || !right || !var) {
    htt_worker_log(worker, HTT_LOG_ERR, "<left> ADD|SUB|MUL|DIV <right> <variable> expected", copy);
    return APR_EINVAL;
  }

  /* get integer value */
  ileft = apr_atoi64(left);
  iright = apr_atoi64(right);

  /* do operation */
  if (strcasecmp(op, "ADD") == 0) {
    result = ileft + iright;
  }
  else if (strcasecmp(op, "SUB") == 0) {
    result = ileft - iright;
  }
  else if (strcasecmp(op, "MUL") == 0) {
    result = ileft * iright;
  }
  else if (strcasecmp(op, "DIV") == 0) {
    if (iright == 0) {
      htt_worker_log(worker, HTT_LOG_ERR, "Division by zero");
      return APR_EINVAL;
    }
    result = ileft / iright;
  }
  else {
    htt_worker_log(worker, HTT_LOG_ERR, "Unknown operant %s", op);
    return APR_ENOTIMPL;
  }

  /* store it do var */
  apr_table_set(worker->vars, var, apr_psprintf(worker->ptmp, "%d", result));
  
  return APR_SUCCESS;
}

/**
 * WHICH command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN varname
 *
 * @return APR_SUCCESS or apr error code
 */
static apr_status_t htt_cmd_WHICH(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;
  char *result;

  HTT_CMD_NEED_ARG("<variable> expected");
 
  result  = apr_psprintf(worker->ptmp, "%d", worker->which);
  apr_table_set(worker->vars, copy, result);
  
  return APR_SUCCESS;
}

/**
 * CERT command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN cert, key and optional ca file
 *
 * @return APR_SUCCESS or apr error code
 */
static apr_status_t htt_cmd_CERT(htt_cmd_t *self, htt_worker_t *worker, char *data) {
  char *copy;
  char *last;
  char *cert;
  char *key;
  char *ca;

  HTT_CMD_NEED_ARG("<cert-file> <key-file>");
  
  if (worker->ssl_ctx) {
    cert = apr_strtok(copy, " ", &last);
    key = apr_strtok(NULL, " ", &last);
    ca = apr_strtok(NULL, " ", &last);
    htt_worker_ssl_ctx(worker, cert, key, 1);
    if (ca && !SSL_CTX_load_verify_locations(worker->ssl_ctx, ca, NULL)) {
	htt_worker_log(worker, HTT_LOG_ERR, "Could not load CA file");
      return APR_EINVAL;
    }
  }
  else {
    htt_worker_log(worker, HTT_LOG_ERR, "Can not set cert, ssl not enabled in CLIENT/SERVER");
    return APR_EINVAL;
  }
  
  return APR_SUCCESS;
}

/**
 * verify callback for peer cert verification for debugging purpose
 * @param cur_ok IN current ok state
 * @param ctx IN X509 store context
 */
static int debug_verify_callback(int cur_ok, X509_STORE_CTX *ctx) {
  char buf[256];
  X509 *err_cert;
  int err, depth;

  err_cert = X509_STORE_CTX_get_current_cert(ctx);
  err = X509_STORE_CTX_get_error(ctx);
  depth = X509_STORE_CTX_get_error_depth(ctx);

  X509_NAME_oneline(X509_get_subject_name(err_cert), buf, 256);
  fprintf(stdout, "\nverify error:num=%d:%s:depth=%d:%s",
	  err, X509_verify_cert_error_string(err), depth, buf);
  return cur_ok;
}

/**
 * VERIFY_PEER command
 *
 * @param self IN command
 * @param worker IN thread data object
 * @param data IN 
 *
 * @return APR_SUCCESS or apr error code
 */
static apr_status_t htt_cmd_VERIFY_PEER(htt_cmd_t *self, htt_worker_t *worker, char *data) {
#ifdef USE_SSL
  int rc;

  X509 *peer_cert = NULL;

  HTT_CMD_NO_ARG;

  if (!worker->socket->is_ssl || !worker->socket->ssl) {
    htt_worker_log(worker, HTT_LOG_ERR, 
	       "No ssl connection established can not verify peer");
    return APR_ENOSOCKET;
  }
  
  if (worker->flags & HTT_FLAGS_SERVER) {
    /* if we are server request the peer cert */
    if (worker->log_mode >= HTT_LOG_DEBUG) {
      SSL_set_verify(worker->socket->ssl,
		     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
		     debug_verify_callback);
    }
    else {
      SSL_set_verify(worker->socket->ssl,
		     SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
		     NULL);
    }

    if((rc = SSL_renegotiate(worker->socket->ssl) <= 0)) {
      htt_worker_log(worker, HTT_LOG_ERR, "SSL renegotiation a error: %d", rc);
      return APR_EINVAL;
    }
    htt_worker_ssl_handshake(worker);
    worker->socket->ssl->state=SSL_ST_ACCEPT;
    htt_worker_ssl_handshake(worker);
  }
  else {
    if((rc = SSL_get_verify_result(worker->socket->ssl))!=X509_V_OK) {
      htt_worker_log(worker, HTT_LOG_ERR, "SSL peer verify failed: %s(%d)",
	         X509_verify_cert_error_string(rc), rc);
      return APR_EINVAL;
    }
  }

  /* if we are client just get the peer cert */
  peer_cert = SSL_get_peer_certificate(worker->socket->ssl);
  
  if (!peer_cert) {
    htt_worker_log(worker, HTT_LOG_ERR, "No peer certificate");
    return APR_EINVAL;
  }
#endif

  return APR_SUCCESS;
}

/**
 * Object fileio 
 */

/**
 * Fill up buffer with data from file 
 *
 * @param self IN fileio object
 *
 * @return an apr status
 */
static apr_status_t htt_fileio_fill(htt_fileio_t * self) {
  self->i = 0;
  self->len = HTT_BLOCK_MAX;

  return apr_file_read(self->fp, self->buf, &self->len);
}

/**
 * read line from file 
 *
 * @param self IN fileio object
 * @param line OUT read line
 *
 * @return an apr status
 */
static apr_status_t htt_fileio_read_line(htt_fileio_t * self, char **line) {
  apr_status_t status;
  char c;
  apr_size_t i;
  apr_size_t size;
  char *new_size_line;

  *line = NULL;
  size = 0;

  i = 0;
  c = 0;
  while (c != '\r' && c != '\n' && apr_file_eof(self->fp) != APR_EOF) {
    if (i >= size) {
      size += 512;
      new_size_line = apr_palloc(self->pool, size + 1);
      if (*line != NULL) {
        memcpy(new_size_line, *line, size - 512);
      }
      *line = new_size_line;
    }
    if (self->i >= self->len) {
      if ((status = htt_fileio_fill(self)) != APR_SUCCESS) {
        return status;
      }
    }

    c = self->buf[self->i];
    (*line)[i] = c;
    self->i++;
    i++;
  }
  if (i) {
    (*line)[i - 1] = 0;
  }
  else {
    (*line)[i] = 0;
  }
  while (**line == ' ') {
    ++*line;
  }
  if (apr_file_eof(self->fp) == APR_EOF) {
    return APR_EOF;
  }
  else {
    return APR_SUCCESS;
  }
}

/**
 * New fileio object 
 *
 * @param self OUT fileio object
 * @param fp IN an open file to read
 * @param p IN pool
 *
 * @return an apr status
 */
static apr_status_t htt_fileio_new(htt_fileio_t ** fileio, apr_file_t * fp,
                                  apr_pool_t * p) {
  apr_status_t status;

  *fileio = apr_pcalloc(p, sizeof(htt_fileio_t));

  (*fileio)->fp = fp;
  (*fileio)->pool = p;

  if ((status = htt_fileio_fill((*fileio))) != APR_SUCCESS) {
    return status;
  }

  return APR_SUCCESS;
}

/**
 * Object thread data
 */

/**
 * New thread data object 
 *
 * @param self OUT thread data object
 * @param log_mode IN log mode  
 *
 * @return an apr status
 */
static apr_status_t htt_worker_new(htt_worker_t ** self, char *additional,
                               int log_mode, char *prefix,
                               apr_thread_cond_t * sync_cond,
                               apr_thread_mutex_t * sync_mutex,
			       apr_time_t socktmo, apr_hash_t *blocks) {
  apr_pool_t *p;
  apr_pool_t *ptmp;

  apr_pool_create(&p, NULL);
  (*self) = apr_pcalloc(p, sizeof(htt_worker_t));
  (*self)->heartbeat = p;
  apr_pool_create(&p, (*self)->heartbeat);
  (*self)->pool = p;
  apr_pool_create(&ptmp, p);
  (*self)->ptmp = ptmp;
  (*self)->filename = apr_pstrdup(p, "<none>");
  (*self)->socktmo = socktmo;
  (*self)->prefix = apr_pstrdup(p, prefix);
  (*self)->additional = apr_pstrdup(p, additional);
  (*self)->sync_cond = sync_cond;
  (*self)->sync_mutex = sync_mutex;
  (*self)->lines = apr_table_make(p, 20);
  (*self)->cache = apr_table_make(p, 20);
  (*self)->expect_dot = apr_table_make(p, 2);
  (*self)->expect_error = apr_table_make(p, 2);
  (*self)->match_headers = apr_table_make(p, 2);
  (*self)->match_body = apr_table_make(p, 2);
  (*self)->match_error = apr_table_make(p, 2);
  (*self)->sockets = apr_hash_make(p);
  (*self)->headers_allow = NULL;
  (*self)->headers_filter = NULL;
  (*self)->vars = apr_table_make(p, 4);
  (*self)->blocks = blocks;
  (*self)->log_mode = log_mode;
#ifdef USE_SSL
  (*self)->bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);
  (*self)->bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
#endif

  htt_worker_log(*self, HTT_LOG_DEBUG, "htt_worker_new: pool: %p, ptmp: %p\n", (*self)->pool, (*self)->ptmp);
  return APR_SUCCESS;
}

/**
 * Clone thread data object 
 *
 * @param self OUT thread data object
 * @param orig IN thread data object to copy from 
 *
 * @return an apr status
 */
static apr_status_t htt_worker_clone(htt_worker_t ** self, htt_worker_t * orig) {
  apr_pool_t *p;
  apr_pool_t *ptmp;

  apr_pool_create(&p, NULL);
  (*self) = apr_pcalloc(p, sizeof(htt_worker_t));
  memcpy(*self, orig, sizeof(htt_worker_t));
  (*self)->heartbeat = p;
  apr_pool_create(&p, (*self)->heartbeat);
  (*self)->pool = p;
  apr_pool_create(&ptmp, p);
  (*self)->ptmp = ptmp;
  (*self)->flags = orig->flags;
  (*self)->prefix = apr_pstrdup(p, orig->prefix);
  (*self)->additional = apr_pstrdup(p, orig->additional);
  (*self)->lines = htt_table_deep_copy(p, orig->lines);
  (*self)->cache = htt_table_deep_copy(p, orig->cache);
  (*self)->expect_dot = htt_table_swallow_copy(p, orig->expect_dot);
  (*self)->expect_error = htt_table_swallow_copy(p, orig->expect_error);
  (*self)->match_headers = htt_table_swallow_copy(p, orig->match_headers);
  (*self)->match_body = htt_table_swallow_copy(p, orig->match_body);
  (*self)->match_error = htt_table_swallow_copy(p, orig->match_error);
  (*self)->listener = NULL;
  (*self)->sockets = apr_hash_make(p);
  if (orig->headers_allow) {
    (*self)->headers_allow = htt_table_deep_copy(p, orig->headers_allow);
  }
  if (orig->headers_filter) {
    (*self)->headers_filter = htt_table_deep_copy(p, orig->headers_filter);
  }
  (*self)->vars = htt_table_deep_copy(p, orig->vars);
#ifdef USE_SSL
  (*self)->bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);
  (*self)->bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
#endif

  htt_worker_log(*self, HTT_LOG_DEBUG, "htt_worker_clone: pool: %p, ptmp: %p\n", (*self)->pool, (*self)->ptmp);
  return APR_SUCCESS;
}
 
/**
 * Clone and copy a body of lines
 *
 * @param body OUT body which has been copied
 * @param worker IN  worker from which we copy the lines for body
 * @param end IN this bodys terminate string
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_worker_body(htt_worker_t **body, htt_worker_t *worker, char *command) {
  char *file_and_line;
  char *line = "";
  apr_table_entry_t *e; 
  apr_pool_t *p;
  char *end;
  char *kind;
  int ends;
  int end_len;
  int kind_len;

  /* create body */
  apr_pool_create(&p, NULL);
  end = apr_pstrcat(p, "_END ", command, NULL);
  end_len = strlen(end);
  kind = apr_pstrcat(p, "_", command, NULL);
  kind_len = strlen(kind);
  ends = 1;
  (*body) = apr_pcalloc(p, sizeof(htt_worker_t));
  memcpy(*body, worker, sizeof(htt_worker_t));
  /* give it an own heartbeat :) */
  (*body)->heartbeat = p;

  /* fill lines */
  (*body)->lines = apr_table_make(p, 20);
  e = (apr_table_entry_t *) apr_table_elts(worker->lines)->elts;
  for (worker->cmd += 1; worker->cmd < apr_table_elts(worker->lines)->nelts; worker->cmd++) {
    file_and_line = e[worker->cmd].key;
    line = e[worker->cmd].val;
    /* count numbers of same kinds to include all their ends */
    if (strlen(line) >= kind_len && strncmp(line, kind, kind_len) == 0) {
      ++ends;
      htt_worker_log(worker, HTT_LOG_DEBUG, "Increment loops: %d for line %s", ends, line);
    }
    /* check end and if it is our end */
    if (strlen(line) >= end_len && strncmp(line, end, end_len) == 0 && ends == 1) {
      break;
    }
    /* no is not our end, decrement ends */
    else if (strlen(line) >= end_len && strncmp(line, end, end_len) == 0) {
      --ends;
      htt_worker_log(worker, HTT_LOG_DEBUG, "Decrement loops: %d for line %s", ends, line);
    }
    apr_table_addn((*body)->lines, file_and_line, line);
  }
  /* check for end */
  if (strlen(line) < end_len || strncmp(line, end, end_len) != 0) {
    htt_worker_log(worker, HTT_LOG_ERR, "Compilation failed: no %s found", end);
    return APR_EGENERAL;
  }

  return APR_SUCCESS;
}
 
/**
 * Close a body 
 *
 * @param body IN body which has been copied
 * @param worker IN  worker from which we copy the lines for body
 */
static void htt_worker_body_end(htt_worker_t *body, htt_worker_t *worker) {
  /* write back sockets and state */
  worker->socket = body->socket;
  worker->listener = body->listener;

  /* destroy body */
  htt_worker_destroy(body);
}

/**
 * Destroy thread data object
 *
 * @param self IN thread data object
 */
static void htt_worker_destroy(htt_worker_t * self) {
  htt_worker_log(self, HTT_LOG_DEBUG, "htt_worker_destroy: %p, ptmp: %p", self->pool, self->ptmp);
  apr_pool_destroy(self->heartbeat);
}

/**
 * Clone thread data object 
 *
 * @param self IN thread data object
 * @param line IN command line
 *
 * @return an apr status
 */
static apr_status_t htt_worker_add_line(htt_worker_t * self, const char *file_and_line,
                                    char *line) {
  apr_table_add(self->lines, file_and_line, line);
  return APR_SUCCESS;
}

static apr_status_t htt_worker_socket_send(htt_worker_t *self, char *buf, 
                                       apr_size_t len) {
  apr_status_t status = APR_SUCCESS;
  apr_size_t total = len;
  apr_size_t count = 0;

  while (total != count) {
    len = total - count;
    if ((status = apr_socket_send(self->socket->socket, &buf[count], &len)) 
	!= APR_SUCCESS) {
      goto error;
    }
    count += len;
  }

error:
  return status;
}

/**
 * flush data 
 *
 * @param self IN thread data object
 *
 * @return an apr status
 */
static apr_status_t htt_worker_flush(htt_worker_t * self) {
  apr_size_t len;
  int i;
  int start;
  char *chunked;

  apr_status_t status = APR_SUCCESS;
  apr_table_entry_t *e =
    (apr_table_entry_t *) apr_table_elts(self->cache)->elts;

  if (!self->socket || !self->socket->socket) {
    goto error;
  }
  
  chunked = NULL;
  if (apr_table_get(self->cache, "Content-Length")) {
    /* calculate body len */
    start = 0;
    len = 0;
    for (i = 0; i < apr_table_elts(self->cache)->nelts; ++i) {
      if (!start && !e[i].val[0]) {
        /* start body len */
        start = 1;
      }
      else if (start) {
        /* do not forget the \r\n */
	if (strncasecmp(e[i].key, "NOCRLF", 6) != 0) {
	  len += 2;
	}
	if (strncasecmp(e[i].key, "NOCRLF:", 7) == 0) { 
	  len += apr_atoi64(&e[i].key[7]);
	}
	else {
          len += strlen(e[i].val);
	}
      }
    }

    apr_table_setn(self->cache, "Content-Length",
                   apr_psprintf(self->pool, "Content-Length: %d", len));
  }
  else if (apr_table_get(self->cache, "CHUNKED")) {
    apr_table_unset(self->cache, "CHUNKED");
    len = 0;
    for (i = 0; i < apr_table_elts(self->cache)->nelts; ++i) {
      /* do not forget the \r\n */
      if (strncasecmp(e[i].key, "NOCRLF", 6) != 0) {
	len += 2;
      }
      if (strncasecmp(e[i].key, "NOCRLF:", 7) == 0) { 
	len += apr_atoi64(&e[i].key[7]);
      }
      else {
	len += strlen(e[i].val);
      }
    }
    chunked = apr_psprintf(self->pool, "\r\n%x\r\n", len);
  }

  if (chunked) {
    htt_worker_log(self, HTT_LOG_INFO, ">");
    htt_worker_log(self, HTT_LOG_INFO, ">%x", len);
    htt_worker_log(self, HTT_LOG_INFO, ">");
  }
#ifdef USE_SSL
  if (self->socket->is_ssl) {
    apr_size_t e_ssl;
    if (chunked) {
      len = strlen(chunked);
    tryagain1:
      apr_sleep(1);
      e_ssl = SSL_write(self->socket->ssl, chunked, len);
      if (e_ssl != len) {
        int scode = SSL_get_error(self->socket->ssl, e_ssl);
        if (scode == SSL_ERROR_WANT_WRITE) {
          goto tryagain1;
        }
        status = APR_ECONNABORTED;
	goto error;
      }
    }
  }
  else
#endif
  {
    if (chunked) {
      len = strlen(chunked);
      if ((status = htt_worker_socket_send(self, chunked, len)) != APR_SUCCESS) {
	goto error;
      }
    }
  }
  /* iterate through all cached lines and send them */
  for (i = 0; i < apr_table_elts(self->cache)->nelts; ++i) {
    if (strncasecmp(e[i].key, "NOCRLF:", 7) == 0) { 
      len = apr_atoi64(&e[i].key[7]);
      htt_worker_log_buf(self, HTT_LOG_INFO, e[i].val, ">", len);
    }
    else {
      len = strlen(e[i].val);
      htt_worker_log(self, HTT_LOG_INFO, ">%s %s", e[i].val, 
	         strcasecmp(e[i].key, "NOCRLF") ? "" : e[i].key);
    }

#ifdef USE_SSL
    if (self->socket->is_ssl) {
      apr_size_t e_ssl;
    tryagain2:
      apr_sleep(1);
      e_ssl = SSL_write(self->socket->ssl, e[i].val, len);
      if (e_ssl != len) {
        int scode = SSL_get_error(self->socket->ssl, e_ssl);
        if (scode == SSL_ERROR_WANT_WRITE) {
          goto tryagain2;
        }
        status = APR_ECONNABORTED;
	goto error;
      }
      if (strncasecmp(e[i].key, "NOCRLF", 6) != 0) {
        len = 2;
      tryagain3:
        apr_sleep(1);
        e_ssl = SSL_write(self->socket->ssl, "\r\n", len);
        if (e_ssl != len) {
	  int scode = SSL_get_error(self->socket->ssl, e_ssl);
	  if (scode == SSL_ERROR_WANT_WRITE) {
	    goto tryagain3;
	  }
	  status = APR_ECONNABORTED;
	  goto error;
	}
      }
    }
    else
#endif
    {
      if ((status = htt_worker_socket_send(self, e[i].val, len)) 
	  != APR_SUCCESS) {
	goto error;
      }
      if (strncasecmp(e[i].key, "NOCRLF", 6) != 0) {
	len = 2;
	if ((status = htt_worker_socket_send(self, "\r\n", len)) != APR_SUCCESS) {
	  goto error;
	}
      }
    }
  }

error:
  apr_table_clear(self->cache);

  return status;
}

/**
 * Lookup function
 *
 * @param line IN line where the command resides
 *
 * @return command index
 */
static int htt_get_func_index(htt_cmd_t *commands, const char *line) {
  int k;
  apr_size_t len;

  k = 0;
  /* lookup command function */
  while (commands[k].name) {
    len = strlen(commands[k].name);
    if (len <= strlen(line)
	&& strncmp(line, commands[k].name, len) == 0) {
      break;
    }
    ++k;
  }

  return k;
}

/**
 * Interpreter
 *
 * @param self IN thread data object
 *
 * @return an apr status
 */
static apr_status_t htt_worker_interpret(htt_worker_t * self, htt_worker_t *parent) {
  apr_status_t status;
  char *line;
  int j;
  int k;

  apr_table_entry_t *e =
    (apr_table_entry_t *) apr_table_elts(self->lines)->elts;

  /* iterate through all script line for this thread */
  for (self->cmd = 0; self->cmd < apr_table_elts(self->lines)->nelts; self->cmd++) {
    self->file_and_line = e[self->cmd].key;
    line = e[self->cmd].val;
    /* lookup function index */
    j = 0;
    k = htt_get_func_index(local_commands, line);
    /* get command end test if found */
    if (local_commands[k].func) {
      j += strlen(local_commands[k].name);
      status = local_commands[k].func(&local_commands[k], self, &line[j]);
      status = htt_worker_check_error(parent, status);
      if (status != APR_SUCCESS) {
        return status;
      }
    }
    else {
      htt_worker_log_error(self, "%s syntax error", self->name);
      htt_worker_set_global_error(self);
      return APR_EINVAL;
    }
  }
  return APR_SUCCESS;
}

/**
 * Call final block if exist
 *
 * @param self IN thread data object
 */
static void htt_worker_finally(htt_worker_t *self, apr_status_t status) {
  int k;
  int log_mode;

  k = htt_get_func_index(local_commands, "_CALL");
  if (local_commands[k].func) {
    log_mode = self->log_mode;
    self->log_mode = HTT_LOG_NONE;
    local_commands[k].func(&local_commands[k], self, "FINALLY");
    self->log_mode = log_mode;
  }

  if (self->flags & HTT_FLAGS_IGNORE_ERRORS) {
    goto exodus;
  } 
  if (status != APR_SUCCESS) {
    k = htt_get_func_index(local_commands, "_CALL");
    if (local_commands[k].func) {
      log_mode = self->log_mode;
      self->log_mode = HTT_LOG_NONE;
      local_commands[k].func(&local_commands[k], self, "ON_ERROR");
      self->log_mode = log_mode;
    }

    htt_worker_set_global_error(self);
//    htt_worker_destroy(self);
    htt_worker_conn_close_all(self);
    exit(status);
  }
exodus:
//  htt_worker_destroy(self);
  htt_worker_conn_close_all(self);
  apr_thread_exit(self->mythread, APR_SUCCESS);
}

/**
 * client thread
 *
 * @param thread IN thread object
 * @param selfv IN void pointer to thread data object
 *
 * @return an apr status
 */
static void *htt_worker_thread_client(apr_thread_t * thread, void *selfv) {
  apr_status_t status;

  htt_worker_t *self = selfv;
  self->mythread = thread;
  self->flags |= HTT_FLAGS_CLIENT;

  self->file_and_line = apr_psprintf(self->pool, "%s:-1", self->filename);

  htt_worker_log(self, HTT_LOG_DEBUG, "Client sync ...");
  /* wait on server startups */
  if ((status = apr_thread_mutex_lock(self->sync_mutex)) != APR_SUCCESS) {
    goto error;
  }

  if ((status = apr_thread_cond_wait(self->sync_cond,
                                     self->sync_mutex)) != APR_SUCCESS) {
    goto error;
  }

  if ((status = apr_thread_mutex_unlock(self->sync_mutex)) != APR_SUCCESS) {
    goto error;
  }

  htt_worker_log(self, HTT_LOG_INFO, "Client start ...");

  if ((status = htt_worker_interpret(self, self)) != APR_SUCCESS) {
    goto error;
  }

  htt_worker_flush(self);

  if ((status = htt_worker_test_unused(self)) != APR_SUCCESS) {
    goto error;
  }

  if ((status = htt_worker_test_unused_errors(self)) != APR_SUCCESS) {
    goto error;
  }

error:
  htt_worker_finally(self, status);
  return NULL;
}

/**
 * server thread
 *
 * @param thread IN thread object
 * @param selfv IN void pointer to thread data object
 *
 * @return 
 */
static void *htt_worker_thread_server(apr_thread_t * thread, void *selfv) {
  apr_status_t status;

  htt_worker_t *self = selfv;
  self->mythread = thread;
  self->flags |= HTT_FLAGS_SERVER;

  if ((status = htt_worker_interpret(self, self)) != APR_SUCCESS) {
    goto error;
  }

  htt_worker_flush(self);

  if ((status = htt_worker_test_unused(self)) != APR_SUCCESS) {
    goto error;
  }

  if ((status = htt_worker_test_unused_errors(self)) != APR_SUCCESS) {
    goto error;
  }

error:
  /* do not close listener, there may be more servers which use this 
   * listener, signal this by setting listener to NULL
   */
  self->listener = NULL;
  htt_worker_finally(self, status);
  return NULL;
}

/**
 * listener server thread
 *
 * @param thread IN thread object
 * @param selfv IN void pointer to thread data object
 *
 * @return an apr status
 */
static void *htt_worker_thread_listener(apr_thread_t * thread, void *selfv) {
  apr_status_t status;
  int i;
  int nolistener;
  char *last;
  char *portname;
  char *value;
  int threads = 0;
  htt_worker_t *clone;
  apr_threadattr_t *tattr;
  apr_thread_t *thread_new;
  apr_table_t *servers;

  htt_worker_t *self = selfv;
  self->mythread = thread;
  self->flags |= HTT_FLAGS_SERVER;

  portname = apr_strtok(self->additional, " ", &last);

  nolistener = 0;
  value = apr_strtok(NULL, " ", &last);
  if (value && strcmp("DOWN", value) != 0) {
    threads = apr_atoi64(value);
  }
  else if (value) {
    /* do not setup listener */
    nolistener = 1;
  }
  else {
    threads = 0;
  }

#ifdef USE_SSL
  self->is_ssl = 0;
  if (strncmp(portname, "SSL:", 4) == 0) {
    self->is_ssl = 1;
    self->meth = SSLv23_server_method();
    portname += 4;
  }
  else if (strncmp(portname, "SSL2:", 4) == 0) {
    self->is_ssl = 1;
    self->meth = SSLv2_server_method();
    portname += 5;
  }
  else if (strncmp(portname, "SSL3:", 4) == 0) {
    self->is_ssl = 1;
    self->meth = SSLv3_server_method();
    portname += 5;
  }
  else if (strncmp(portname, "TLS1:", 4) == 0) {
    self->is_ssl = 1;
    self->meth = TLSv1_server_method();
    portname += 5;
  }

  if ((status = htt_worker_ssl_ctx(self, HTT_RSA_SERVER_CERT, HTT_RSA_SERVER_KEY, 0)) 
      != APR_SUCCESS) {
    goto error;
  }
#endif

  self->listener_port = apr_atoi64(portname);
  htt_worker_log(self, HTT_LOG_INFO, "Start Server: %d", self->listener_port);

  if (!nolistener) {
    if ((status = htt_worker_listener_up(self)) != APR_SUCCESS) {
      goto error;
    }
  }

  if (threads != 0) {
    i = 0;

    if ((status = apr_threadattr_create(&tattr, self->pool)) != APR_SUCCESS) {
      goto error;
    }

    if ((status = apr_threadattr_stacksize_set(tattr, DEFAULT_THREAD_STACKSIZE))
	!= APR_SUCCESS) {
      goto error;
    }

    if ((status = apr_threadattr_detach_set(tattr, 1)) != APR_SUCCESS) {
      goto error;
    }

    servers = apr_table_make(self->pool, 10);

    while(threads == -1 || i < threads) {
      if ((status = htt_worker_clone(&clone, self)) != APR_SUCCESS) {
	htt_worker_log(self, HTT_LOG_ERR, "Could not clone server thread data");
	goto error;
      }
      clone->listener = self->listener;
      htt_worker_log(self, HTT_LOG_DEBUG, "--- accept");
      if (!self->listener) {
	htt_worker_log_error(self, "Server down");
	status = APR_EGENERAL;
	goto error;
      }

      htt_worker_get_socket(clone, "Default", "0", NULL);
      clone->socket->is_ssl = clone->is_ssl;
      
      if ((status =
	   apr_socket_accept(&clone->socket->socket, self->listener,
			     clone->pool)) != APR_SUCCESS) {
	clone->socket->socket = NULL;
	goto error;
      }
      if ((status =
             apr_socket_timeout_set(clone->socket->socket, self->socktmo)) 
	  != APR_SUCCESS) {
        goto error;
      }
#ifdef USE_SSL
      if ((status = htt_worker_ssl_accept(clone)) != APR_SUCCESS) {
	goto error;
      }
#endif
      htt_worker_log(self, HTT_LOG_DEBUG, "--- create thread");
      clone->socket->socket_state = HTT_SOCK_CONNECTED;
      clone->which = i;
      if ((status =
	   apr_thread_create(&thread_new, tattr, htt_worker_thread_server,
			     clone, self->pool)) != APR_SUCCESS) {
	goto error;
      }
      ++i;
    }
  }
  else {
    if ((status = htt_worker_interpret(self, self)) != APR_SUCCESS) {
      goto error;
    }

    htt_worker_flush(self);

    if ((status = htt_worker_test_unused(self)) != APR_SUCCESS) {
      goto error;
    }

    if ((status = htt_worker_test_unused_errors(self)) != APR_SUCCESS) {
      goto error;
    }
  }

error:
  htt_worker_finally(self, status);
  return NULL;
}

/****
 * Global object 
 ****/

/**
 * Create new global object
 *
 * @param self OUT new global object
 * @param vars IN global variable table
 * @param log_mode IN log mode
 * @param p IN pool
 *
 * @return apr status
 */
static apr_status_t htt_global_new(htt_global_t **self, apr_table_t *vars, 
                               int log_mode, apr_pool_t *p) {
  apr_status_t status;
  *self = apr_pcalloc(p, sizeof(htt_global_t));

  (*self)->pool = p;
  (*self)->vars = vars;
  (*self)->log_mode = log_mode;

  (*self)->threads = apr_table_make(p, 10);
  (*self)->blocks = apr_hash_make(p);

  if ((status = apr_threadattr_create(&(*self)->tattr, (*self)->pool)) != APR_SUCCESS) {
    return status;
  }

  if ((status = apr_threadattr_stacksize_set((*self)->tattr, DEFAULT_THREAD_STACKSIZE))
      != APR_SUCCESS) {
    return status;
  }

  if ((status = apr_threadattr_detach_set((*self)->tattr, 0)) != APR_SUCCESS) {
    return status;
  }

  if ((status = apr_thread_cond_create(&(*self)->cond, p)) != APR_SUCCESS) {
    return status;
  }

  if ((status = apr_thread_mutex_create(&(*self)->mutex, 
	                                APR_THREAD_MUTEX_DEFAULT,
                                        p)) != APR_SUCCESS) {
    return status;
  }
 
  (*self)->state = HTT_STATE_NONE;
  (*self)->socktmo = 300000000;
  (*self)->prefix = apr_pstrdup(p, "");

  return APR_SUCCESS;
}

/**
 * Global CLIENT command
 *
 * @param self IN global object
 * @param data IN additional 
 *
 * @return apr status 
 */
static apr_status_t htt_global_END(htt_cmd_t *self, htt_global_t *global, char *data) {
  int concurrent;
  char *last;
  char *val;
  char *name;
  char *called_name;
  apr_thread_start_t thread_run;
  htt_worker_t *clone;
  apr_thread_t *thread;
  apr_status_t status;

  /* start client server deamon */
  if (global->state == HTT_STATE_CLIENT) {
    /* get number of concurrent default is 1 */
    val = apr_strtok(global->worker->additional, " ", &last);
    if (val) {
      concurrent = apr_atoi64(val);
      if (concurrent <= 0) {
	fprintf(stderr, "\nNumber of concurrent clients must be > 0");
	return EINVAL;
      }
      global->worker->additional = NULL;
    }
    else {
      concurrent = 1;
    }
    thread_run = htt_worker_thread_client;
    name = apr_psprintf(global->pool, "CLT%d", global->CLTs);
    ++global->CLTs;
  }
  else if (global->state == HTT_STATE_SERVER) {
    thread_run = htt_worker_thread_listener;
    name = apr_psprintf(global->pool, "SRV%d", global->SRVs);
    concurrent = 1;
    ++global->SRVs;
  }
  else if (global->state == HTT_STATE_BLOCK) {
    /* store block */
    apr_hash_set(global->blocks, global->worker->name, APR_HASH_KEY_STRING, 
	         global->worker);
    global->state = HTT_STATE_NONE;
    return APR_SUCCESS;
  }
  else if (global->state == HTT_STATE_DAEMON) {
    /* get number of concurrent default is 1 */
    concurrent = 1;
    thread_run = htt_worker_thread_client;
    name = apr_pstrdup(global->pool, "DMN");
  }
  else {
    fprintf(stderr, "\nUnknown close of a body definition");
    return APR_ENOTIMPL;
  }
  global->worker->filename = global->filename;
  while (concurrent) {
    clone = NULL;
    --concurrent;
    called_name = apr_psprintf(global->pool, "%s-%d", name, concurrent);
    global->worker->name = called_name;
    global->worker->which = concurrent;
    if (concurrent) {
      if ((status = htt_worker_clone(&clone, global->worker)) != APR_SUCCESS) {
	htt_worker_log(global->worker, HTT_LOG_ERR, "Could not clone thread");
	return APR_EINVAL;
      }
    }

    if ((status =
	 apr_thread_create(&thread, global->tattr, thread_run,
			   global->worker, global->pool)) != APR_SUCCESS) {
      return status;
    }
    if (global->state != HTT_STATE_DAEMON) {
      apr_table_addn(global->threads, called_name, (char *) thread);
    }
    global->worker = clone;
  }
  /* reset */
  global->state = HTT_STATE_NONE;

  return APR_SUCCESS;
}

/**
 * Global worker defintion 
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN additional 
 * @param state IN CLIENT | SERVER
 *
 * @return apr status 
 */
static apr_status_t htt_global_worker(htt_cmd_t *self, htt_global_t *global, char *data, int state) {
  apr_status_t status;

  /* Client start */
  global->state = state;
  if ((status = htt_worker_new(&global->worker, data, global->log_mode, 
	                   global->prefix, global->cond, global->mutex, 
			   global->socktmo, global->blocks)) != APR_SUCCESS) {
    return status;
  }
  global->prefix = apr_pstrcat(global->pool, global->prefix, 
			     "                        ", NULL);
  return APR_SUCCESS;
}

/**
 * Global CLIENT command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN additional 
 *
 * @return apr status 
 */
static apr_status_t htt_global_CLIENT(htt_cmd_t *self, htt_global_t *global, char *data) {
  return htt_global_worker(self, global, data, HTT_STATE_CLIENT);
}

/**
 * Global SERVER command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN additional 
 *
 * @return apr status 
 */
static apr_status_t htt_global_SERVER(htt_cmd_t *self, htt_global_t *global, char *data) {
  return htt_global_worker(self, global, data, HTT_STATE_SERVER);
}

/**
 * global BLOCK command 
 *
 * @param self IN command object
 * @param worker IN global object
 * @param data IN name
 *
 * @return an apr status
 */
static apr_status_t htt_global_BLOCK(htt_cmd_t * self, htt_global_t * global,
                                 char *data) {
  apr_status_t status;

  while (*data == ' ') ++data;
  
  /* Block start */
  global->state = HTT_STATE_BLOCK;

  /* Start a new worker */
  if ((status = htt_worker_new(&global->worker, data, global->log_mode, 
	                   global->prefix, global->cond, global->mutex, 
			   global->socktmo, global->blocks)) != APR_SUCCESS) {
    return status;
  }

  global->worker->name = data;
  
  /* A block has its callies prefix I suppose */
  global->prefix = apr_pstrcat(global->pool, global->prefix, "", NULL);

  return APR_SUCCESS;
}

/**
 * Global DAEMON command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN additional 
 *
 * @return apr status 
 */
static apr_status_t htt_global_DAEMON(htt_cmd_t *self, htt_global_t *global, char *data) {
  return htt_global_worker(self, global, data, HTT_STATE_DAEMON);
}

/**
 * Global EXEC command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN shell command 
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_global_EXEC(htt_cmd_t *self, htt_global_t *global, char *data) {
  apr_status_t status;
  htt_worker_t *worker;

  int i = 0;
  
  while (data[i] == ' ') {
    ++i;
  }

  if ((status = htt_worker_new(&worker, &data[i], global->log_mode, "",
			   global->cond, global->mutex, global->socktmo,
			   global->blocks)) 
      != APR_SUCCESS) {
    return status;
  }
  htt_worker_add_line(worker, apr_psprintf(global->pool, "%s:%d", global->filename,
	                               global->line_nr), 
		  apr_pstrcat(worker->pool, "_EXEC ", &data[i], NULL));
  status = htt_worker_interpret(worker, worker);
  if (status != APR_SUCCESS) {
    htt_worker_set_global_error(worker);
  }

  htt_worker_destroy(worker);

  return status;
}

/**
 * Global SET command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN key=value
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_global_SET(htt_cmd_t *self, htt_global_t *global, char *data) {
  char *last;
  char *key;
  char *val;
  
  int i = 0;
  
  while (data[i] == ' ') {
    ++i;
  }
  key = apr_strtok(&data[i], "=", &last);
  val = apr_strtok(NULL, "", &last);
  if (val) {
    apr_table_set(global->vars, key, val);
  }
  else {
    apr_table_set(global->vars, key, "");
  }

  return APR_SUCCESS;
}

/**
 * Global INCLUDE command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN key=value
 *
 * @return APR_SUCCESS
 */
static apr_status_t interpret_recursiv(apr_file_t *fp, htt_global_t *global); 
static apr_status_t htt_global_INCLUDE(htt_cmd_t *self, htt_global_t *global, char *data) {
  apr_status_t status;
  apr_file_t *fp;
  const char *prev_filename;

  int i = 0;
  while (data[i] == ' ') {
    ++i;
  }
  /* open include file */
  if ((status =
       apr_file_open(&fp, &data[i], APR_READ, APR_OS_DEFAULT,
		     global->pool)) != APR_SUCCESS) {
    fprintf(stderr, "\nInclude file %s not found", &data[i]);
    return APR_ENOENT;
  }

  ++global->recursiv;
  prev_filename = global->filename;
  global->filename = &data[i];
  status = interpret_recursiv(fp, global);
  global->filename = prev_filename;

  apr_file_close(fp);

  return status;
}

/**
 * Global TIMEOUT command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN timeout (starting spaces are possible) 
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_global_TIMEOUT(htt_cmd_t *self, htt_global_t *global, char *data) {
  int i = 0;
  
  while (data[i] == ' ') {
    ++i;
  }

  global->socktmo = 1000 * apr_atoi64(&data[i]);

  return APR_SUCCESS;
}

/**
 * Global GO command
 *
 * @param self IN command
 * @param global IN global object
 * @param data IN unused
 *
 * @return APR_SUCCESS
 */
static apr_status_t htt_global_GO(htt_cmd_t *self, htt_global_t *global, char *data) {
  apr_status_t status;

  while ((status = apr_thread_cond_broadcast(global->cond)) != APR_SUCCESS);

  return APR_SUCCESS;
}

/**
 * Recursiv interpreter. Can handle recursiv calls to with sub files i.e. INCLUDE.
 *
 * @param fp IN current open file
 * @param vars IN global variable table
 * @param log_mode IN log mode
 * @param p IN pool
 * @param threads IN table of running threads
 * @param CLTs IN number of current client
 * @param SRVs IN number of current server
 * @param recursiv IN recursiv level to avoid infinit recursion
 *
 * @return apr status
 */
static apr_status_t interpret_recursiv(apr_file_t *fp, htt_global_t *global) {
  apr_status_t status;
  htt_fileio_t *fileio;
  char *line;
  int k;
  int i;
  int line_nr;

  if (global->recursiv > 8) {
    fprintf(stderr, "\nRecursiv inlcudes too deep");
    exit(1);
  }

  if ((status = htt_fileio_new(&fileio, fp, global->pool)) != APR_SUCCESS) {
    return status;
  }

  line_nr = 0;
  while (htt_fileio_read_line(fileio, &line) == APR_SUCCESS) {
    ++line_nr;
    global->line_nr = line_nr;
    i = 0;
    if (line[i] != '#' && line[i] != 0) {
      /* replace all variables */
      line = htt_replace_vars(global->pool, &line[i], global->vars);

      /* lets see if we can start thread */
      if (global->state != HTT_STATE_NONE) {
        if ((strlen(line) >= 3 && strncmp(line, "END", 3) == 0)) { 
	  i += 3;
	  if ((status = htt_global_END(&htt_global_commands[0], global, &line[i])) != APR_SUCCESS) {
	    return status;
	  }
        }
        else if (line[0] == '_' && 
	         (status = htt_worker_add_line(global->worker, 
		                           apr_psprintf(global->pool, "%s:%d", 
					                global->filename, 
							line_nr), line)) !=
                 APR_SUCCESS) {
          return status;
        }
	else if (line[0] != '_') {
          fprintf(stderr, "\n<none>:%d: Missing END", global->line_nr);
	  return APR_EGENERAL;
	}
      }
      else {
        /* lookup function index */
	i = 0;
        k = htt_get_func_index(htt_global_commands, line);
	/* found command? */
	if (htt_global_commands[k].func) {
	  i += strlen(htt_global_commands[k].name);
	  if ((status =
	       htt_global_commands[k].func(&htt_global_commands[k], global,
				       &line[i])) != APR_SUCCESS) {
	    return status;
	  }
	}
	else {
	  /* I ignore unknown commands to be able to set tags like 
	   * DECLARE_SLOW_TEST
	   */
	}
      }
    }
  }

  if (global->state != HTT_STATE_NONE) {
    fprintf(stderr, "\n<none>:%d: Missing END", global->line_nr);
    return APR_EGENERAL;
  }

  return APR_SUCCESS;
}

/**
 * root interpreter
 *
 * @param fp IN open file to interpret
 * @param vars IN host and port file
 * @param log_mode IN log mode
 * @param p IN pool
 *
 * @return an apr status
 */
static apr_status_t interpret(apr_file_t * fp, apr_table_t * vars,
                              int log_mode, apr_pool_t * p) {
  apr_status_t status;
  apr_status_t retstat = APR_SUCCESS;
  apr_thread_t *thread;
  apr_table_entry_t *e;
  int i;
  const char *name;
  htt_global_t *global;

  if ((status = htt_global_new(&global, vars, log_mode, p)) 
      != APR_SUCCESS) {
    return status;
  }
  
  apr_file_name_get(&global->filename, fp);
  if ((status = interpret_recursiv(fp, global)) != APR_SUCCESS) {
    return status;
  }

  /* signal all */
  apr_sleep(200000);
  while ((status = apr_thread_cond_broadcast(global->cond)) != APR_SUCCESS);

  /* wait on thermination of all started threads */

  e = (apr_table_entry_t *) apr_table_elts(global->threads)->elts;

  for (i = 0; i < apr_table_elts(global->threads)->nelts; ++i) {
    thread = (apr_thread_t *) e[i].val;
    name = e[i].key;
    if ((retstat = apr_thread_join(&status, thread))) {
      return retstat;
    }
    if (status != APR_SUCCESS) {
      return status;
    }
  }

  return retstat;
}

/**
 * display copyright information
 */
static void copyright(void) {
  printf("\nThis is Http Test Tool " VERSION);
}

/** 
 * display usage information
 *
 * @progname IN name of the programm
 */
static void usage(const char *progname) {
  fprintf(stdout, "\nUsage: %s [options] scripts", progname);
  fprintf(stdout, "\nOptions are:");
  fprintf(stdout, "\n    -V      Print version number and exit");
  fprintf(stdout, "\n    -h      Display usage information (this message)");
  fprintf(stdout, "\n    -n      no start and OK|FAILED output");
  fprintf(stdout, "\n    -s      silent mode");
  fprintf(stdout, "\n    -e      error mode");
  fprintf(stdout, "\n    -w      warn mode");
  fprintf(stdout, "\n    -d      debug mode");
  fprintf(stdout, "\n    -L      List all available shell commands");
  fprintf(stdout, "\n    -T      Time stamp on every run");
  fprintf(stdout, "\n    -S      Shell mode");
  fprintf(stdout, "\n");
  exit(EINVAL);
}

static void show_commands(void) {
  int i;

  fprintf(stdout, "\nGlobal Commands");
  fprintf(stdout, "\n---------------");
  i = 0;
  while (htt_global_commands[i].name) { 
    fprintf(stdout, "\n\n%s %s\n%s", htt_global_commands[i].name, 
	    htt_global_commands[i].syntax, htt_global_commands[i].help);
    ++i;
  }
  fprintf(stdout, "\n\n\nLocal Commands ");
  fprintf(stdout, "\n--------------");
  i = 0;
  while (local_commands[i].name) { 
    fprintf(stdout, "\n\n%s %s\n%s", local_commands[i].name, 
	    local_commands[i].syntax, local_commands[i].help);
    ++i;
  }
  fprintf(stdout, "\n\n");
  fflush(stdout);
  exit(0);
}

static void htt_exit() {
  if (!success) {
    fprintf(stderr, " FAILED\n");
    fflush(stderr);
  }
  else {
    fprintf(stdout, " OK\n");
    fflush(stdout);
  }
}

static void no_output_exit() {
}

/** 
 * sort out command-line args and call test 
 *
 * @param argc IN number of arguments
 * @param argv IN argument array
 *
 * @return 0 if success
 */
int main(int argc, const char *const argv[]) {
  apr_status_t status;
  apr_getopt_t *opt;
  const char *optarg;
  char c;
  apr_pool_t *pool;
  char *cur_file;
  apr_file_t *fp;
  apr_table_t *vars_table;
  int log_mode;
#define MAIN_FLAGS_NONE 0
#define MAIN_FLAGS_PRINT_TSTAMP 1
#define MAIN_FLAGS_USE_STDIN 2
#define MAIN_FLAGS_NO_OUTPUT 4
  int flags;
  apr_time_t time;
  char time_str[256];

  srand(apr_time_now()); 
  
  apr_app_initialize(&argc, &argv, NULL);
  apr_pool_create(&pool, NULL);

  /* block broken pipe signal */
  apr_signal_block(SIGPIPE);
  
  /* set default */
  log_mode = HTT_LOG_INFO;
  flags = MAIN_FLAGS_NONE;

  /* get options */
  apr_getopt_init(&opt, pool, argc, argv);
  while ((status = apr_getopt(opt, "VhnsewdLTS", &c, &optarg)) == APR_SUCCESS) {
    switch (c) {
    case 'h':
      usage(argv[0]);
      break;
    case 'V':
      atexit(htt_exit);
      copyright();
      return 0;
      break;
    case 'n':
      flags |= MAIN_FLAGS_NO_OUTPUT; 
      break;
    case 's':
      log_mode = HTT_LOG_NONE;
      break;
    case 'e':
      log_mode = HTT_LOG_ERR;
      break;
    case 'd':
      log_mode = HTT_LOG_DEBUG;
      break;
    case 'w':
      log_mode = HTT_LOG_WARN;
      break;
    case 'L':
      show_commands();
      break;
    case 'T':
      flags |= MAIN_FLAGS_PRINT_TSTAMP; 
      break;
    case 'S':
      flags |= MAIN_FLAGS_USE_STDIN; 
      break;
    }
  }
  if (flags & MAIN_FLAGS_NO_OUTPUT) {
    atexit(no_output_exit);
  }
  else {
    atexit(htt_exit);
  }

  /* test for wrong options */
  if (!APR_STATUS_IS_EOF(status)) {
    usage(argv[0]);
  }

  /* test at least one file */
  if (!(flags & MAIN_FLAGS_USE_STDIN) && !(argc - opt->ind)) {
    fprintf(stderr, "\n%s: wrong number of arguments", argv[0]);
    usage(argv[0]);
  }

#ifdef USE_SSL
  /* setup ssl library */
#ifdef RSAREF
  R_malloc_init();
#else
  CRYPTO_malloc_init();
#endif
  SSL_load_error_strings();
  SSL_library_init();
  htt_ssl_thread_setup(pool);
#endif

  /* do for all files (no wild card support) */
  while (flags & MAIN_FLAGS_USE_STDIN || argc - opt->ind) {
    if (flags & MAIN_FLAGS_USE_STDIN) {
      cur_file = apr_pstrdup(pool, "<stdin>");
    }
    else {
      cur_file = apr_pstrdup(pool, opt->argv[opt->ind++]);
    }

    if (flags & MAIN_FLAGS_USE_STDIN) {
      fprintf(stdout, "simple htt shell\n");
    }
    else if (flags & MAIN_FLAGS_PRINT_TSTAMP) {
      time = apr_time_now();
      if ((status = apr_ctime(time_str, time)) != APR_SUCCESS) {
	fprintf(stderr, "Could not format time: %s (%d)\n", 
	        htt_status_str(pool, status), status);
	exit(status);
      }
      if (!(flags & MAIN_FLAGS_NO_OUTPUT)) {
	fprintf(stdout, "%s  run %-54s\t", time_str, cur_file);
      }
    }
    else {
      if (!(flags & MAIN_FLAGS_NO_OUTPUT)) {
	fprintf(stdout, "run %-80s\t", cur_file);
      }
    }
    fflush(stdout);

    /* open current file */
    if (flags & MAIN_FLAGS_USE_STDIN) {
      if ((status = apr_file_open_stdin(&fp, pool)) != APR_SUCCESS) {
	fprintf(stderr, "Could not open stdin: %s (%d)\n", 
	        htt_status_str(pool, status), status);
	exit(status);
      }
    }
    else if ((status =
              apr_file_open(&fp, cur_file, APR_READ, APR_OS_DEFAULT,
                            pool)) != APR_SUCCESS) {
      fprintf(stderr, "\nCould not open %s: %s (%d)", cur_file,
	      htt_status_str(pool, status), status);
      exit(status);
    }

    /* create a global vars table */
    vars_table = apr_table_make(pool, 20);

    /* interpret current file */
    if ((status = interpret(fp, vars_table, log_mode, pool)) != APR_SUCCESS) {
      exit(status);
    }

    /* close current file */
    apr_file_close(fp);

    if (flags & MAIN_FLAGS_USE_STDIN) {
      break;
    }
  }
  apr_pool_destroy(pool);

  return 0;
}


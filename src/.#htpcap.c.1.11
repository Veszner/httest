/* contributor license agreements. 
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file
 *
 * @Author christian liesch <liesch@gmx.ch>
 *
 * Implementation of the HTTP Test pcap.
 */

/* affects include files on Solaris */
#define BSD_COMP

/************************************************************************
 * Includes
 ***********************************************************************/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef PCAP_SUPPORT
#include <pcap.h>

#include <endian.h>
#include <netinet/in.h>

#include <apr.h>
#include <apr_lib.h>
#include <apr_signal.h>
#include <apr_strings.h>
#include <apr_getopt.h>
#include <apr_portable.h>
#include <apr_errno.h>

#include "defines.h"
#include "file.h"
#include "util.h"

/************************************************************************
 * Defines 
 ***********************************************************************/
#define HTPCAP_FLAGS_NONE 0
#define HTPCAP_FLAGS_CLIENT 1
#define HTPCAP_FLAGS_SERVER 2

/************************************************************************
 * Typedefs 
 ***********************************************************************/
typedef struct queue_s {
  u_int32_t seq;
} queue_t;

typedef struct htpcap_s {
  apr_pool_t *pool;
  int flags;
  apr_file_t *fp;
  int link_size;
  char *client;
  char *server;
  u_int16_t server_port;
  u_int16_t src;
  u_int16_t dst;
#define QUEUE_CLIENT 0
#define QUEUE_SERVER 1
  queue_t queue[2];
} htpcap_t;

typedef struct ipv4_s {
#if __BYTE_ORDER == __LITTLE_ENDIAN
  unsigned int hdrlen:4;
  unsigned int version:4;
#else
  unsigned int version:4;
  unsigned int hdrlen:4;
#endif
  u_int8_t tos;
  u_int16_t len;
  u_int16_t id;
  u_int16_t frag_off;
  u_int8_t ttl;
  u_int8_t protocol;
  u_int16_t check;
  u_int32_t src;
  u_int32_t dest;
} ipv4_t;

typedef struct tcp_s
  {
    u_int16_t src;
    u_int16_t dst;
    u_int32_t seq;
    u_int32_t ack_seq;
#if __BYTE_ORDER == __LITTLE_ENDIAN
    u_int16_t reserved1:4;
    u_int16_t off:4;
    u_int16_t fin:1;
    u_int16_t syn:1;
    u_int16_t rst:1;
    u_int16_t psh:1;
    u_int16_t ack:1;
    u_int16_t urg:1;
    u_int16_t reserved2:2;
#else
    u_int16_t off:4;
    u_int16_t reserved1:4;
    u_int16_t reserved2:2;
    u_int16_t urg:1;
    u_int16_t ack:1;
    u_int16_t psh:1;
    u_int16_t rst:1;
    u_int16_t syn:1;
    u_int16_t fin:1;
#  endif
    u_int16_t window;
    u_int16_t check;
    u_int16_t urg_ptr;
} tcp_t;

/************************************************************************
 * Implementation 
 ***********************************************************************/
/**
 * display copyright information
 */
static void copyright(void) {
  printf("\npcap to httest converter " VERSION);
  fprintf(stdout, "\n");
}

/** 
 * display usage information
 *
 * @progname IN name of the programm
 */
static void usage(const char *progname) {
  fprintf(stdout, "\nUsage: %s [options] pcap-file", progname);
  fprintf(stdout, "\nOptions are:");
  fprintf(stdout, "\n    -V      Print version number and exit");
  fprintf(stdout, "\n    -h      Display usage information (this message)");
  fprintf(stdout, "\n    -o      output file");
  fprintf(stdout, "\n    -f      filter");
  fprintf(stdout, "\n    -c      client");
  fprintf(stdout, "\n    -s      server");
  fprintf(stdout, "\n    -a      client ip");
  fprintf(stdout, "\n    -b      server ip:port");
  fprintf(stdout, "\n");
  fprintf(stdout, "\nexample> %s -a 192.168.1.34 -b 192.168.1.100:80 foo.pcap",
          progname);
  fprintf(stdout, "\n");
}

static void htpcap_queue(htpcap_t *self, int queue, u_int32_t seq, 
                         const u_char *payload, int len) {
  /* check seq number */
  if (self->queue[queue].seq < seq) {
    /* initialize seq number */
    self->queue[queue].seq = seq;
  }
  fprintf(stderr, "len: %d\n", len);
}

/**
 * pcap to httest script engine
 *
 * @param user IN u_char pointer to htpcap_t structure
 * @param h IN packet infos 
 * @param bytes IN captured packet bytes
 */
static void htpcap_handler(u_char *user, const struct pcap_pkthdr *h, 
                    const u_char *bytes) {
  tcp_t *tcp;
  int payload_len;
  const u_char *payload; 
  int totlen;

  htpcap_t *self = (void *) user;
  ipv4_t * ipv4 = (ipv4_t *)(bytes + self->link_size);

  /* producer push data to queue */
  if (ipv4->protocol == IPPROTO_TCP) {
    tcp = (tcp_t *)(bytes + self->link_size + 4 * ipv4->hdrlen);
    payload = (u_char *)(bytes + self->link_size + 4 * ipv4->hdrlen + 4 * tcp->off);
    payload_len = ntohs(ipv4->len) - 4 * ipv4->hdrlen - 4 * tcp->off;
    totlen = h->caplen - (self->link_size + 4 * ipv4->hdrlen + 4 * tcp->off); 
    if (payload_len > totlen) {
      /* stop here this tcpdump does dump only part of the payload */
      fprintf(stderr, "\nERROR tcpump has only partial payload\n");
    }
    if (payload_len) {
      fprintf(stderr, "payload_len: %d, totlen: %d, caplen: %d\n", payload_len, totlen, h->caplen);
      /* store payload in corresponding queue */ 
      apr_file_printf(self->fp, "# src port: %d -> dst port: %d\n", ntohs(tcp->src), ntohs(tcp->dst));
      if (ntohs(tcp->dst) != self->dst || ntohs(tcp->src) != self->src) {
	if (ntohs(tcp->dst) == self->server_port) {
	  htpcap_queue(self, QUEUE_CLIENT, ntohl(tcp->seq), payload, payload_len);
	  apr_file_printf(self->fp, "_REQ %s %d:%d\n", self->server, self->server_port, ntohs(tcp->src)); 
	}
	else {
	  htpcap_queue(self, QUEUE_SERVER, ntohl(tcp->seq), payload, payload_len);
	  apr_file_printf(self->fp, "_RES\n");
	}
	self->src = ntohs(tcp->src);
	self->dst = ntohs(tcp->dst);
      }
    }
    else if (tcp->syn) {
      if (ntohs(tcp->dst) != self->dst || ntohs(tcp->src) != self->src) {
	if (ntohs(tcp->dst) == self->server_port) {
	  self->queue[QUEUE_CLIENT].seq += 1;
	}
	else {
	  self->queue[QUEUE_SERVER].seq += 1;
	}
      }
    }
  }
  else {
    /* nothing to do */
  }
}

/** 
 * call procotcol capture 
 *
 * @param argc IN number of arguments
 * @param argv IN argument array
 *
 * @return 0 if success
 */
int main(int argc, const char *const argv[]) {
  apr_status_t status;
  apr_getopt_t *opt;
  const char *optarg;
  char c;
  apr_pool_t *pool;
  const char *input;
  char errbuf[PCAP_ERRBUF_SIZE];
  htpcap_t *self;
  struct bpf_program bpf;
  char *server_ip;
  char *server_port;
  char *last;

  const char *output = NULL;
  char *filter = NULL;
  pcap_t *pcap = NULL;
  char *client_ip = NULL;
  char *server_ip_port = NULL;

  apr_app_initialize(&argc, &argv, NULL);
  apr_pool_create(&pool, NULL);

  /* block broken pipe signal */
  apr_signal_block(SIGPIPE);
  
  self = apr_pcalloc(pool, sizeof(*self));
  self->pool = pool;
  self->flags = HTPCAP_FLAGS_NONE;

  /* get options */
  apr_getopt_init(&opt, pool, argc, argv);
  while ((status = apr_getopt(opt, "Vho:a:b:cs", &c, &optarg)) 
        == APR_SUCCESS) {
    switch (c) {
    case 'h':
      usage(argv[0]);
      return 0;
    case 'V':
      copyright();
      return 0;
      break;
    case 'o':
      output = apr_pstrdup(pool, optarg);
      break;
    case 'a':
      client_ip = apr_pstrdup(pool, optarg);
      break;
    case 'b':
      server_ip_port = apr_pstrdup(pool, optarg);
      break;
    case 'c':
      self->flags |= HTPCAP_FLAGS_CLIENT;
      break;
    case 's':
      self->flags |= HTPCAP_FLAGS_SERVER;
      break;
    }
  }

  /* at least the pcap file */
  if (!(argc - opt->ind)) {
    usage(argv[0]);
    return 1;
  }

  /* do sanity tests */
  if (!client_ip) {
    fprintf(stderr, "\nClient ip not spezified\n");
    return 1;
  }
  
  if (!server_ip_port) {
    fprintf(stderr, "\nServer ip and port not spezified\n");
    return 1;
  }

  /* open output */
  if (output) {
    if ((status = apr_file_open(&self->fp, output, 
	                        APR_CREATE|APR_READ|APR_WRITE|APR_TRUNCATE, 
				APR_OS_DEFAULT, pool))
	!= APR_SUCCESS) {
      fprintf(stderr, "\nERROR %s\n", my_status_str(pool, status));
      return status;
    }
  }
  else {
    if ((status = apr_file_open_stdout(&self->fp, pool)) != APR_SUCCESS) {
      fprintf(stderr, "\nERROR %s\n", my_status_str(pool, status));
      return status;
    }
  }
  
  /* open pcap file */
  input = apr_pstrdup(pool, opt->argv[opt->ind++]);
  if ((pcap = pcap_open_offline(input, errbuf)) == NULL) {
    fprintf(stderr, "\nCould not open pcap file: %s\n", errbuf);
    return 1;
  }


  /* build up filter */
  server_ip = apr_strtok(server_ip_port, ":", &last);
  server_port = apr_strtok(NULL, ":", &last);
  
  if (server_port == NULL) {
    fprintf(stderr, "\nServer port not spezified\n");
  }
  
  self->client = client_ip;
  self->server = server_ip;
  self->server_port = apr_atoi64(server_port);

  filter = apr_psprintf(pool, "host %s and host %s and tcp port %s", client_ip, server_ip, server_port);
  fprintf(stdout, "%s\n", filter);
  
  /* compile filter */
  if (filter) {
    if (pcap_compile(pcap, &bpf, filter, 0, 0) < 0) {
      fprintf(stderr, "\nCompile filter failed: %s\n", pcap_geterr(pcap));
      return 1;
    }
    if (pcap_setfilter(pcap, &bpf) < 0) {
      fprintf(stderr, "\nCompile filter failed: %s\n", pcap_geterr(pcap));
      return 1;
    }
  }
  
  /* get datalink type, only ethernet is supported yet */
  if (pcap_datalink(pcap) != DLT_EN10MB) {
    fprintf(stderr, "\nOnly ethernet is supported\n");
    return 1;
  }

  self->link_size = 14;

  /* loop through all captured packets */
  pcap_loop(pcap, -1, htpcap_handler, (u_char *)self);
  
  fprintf(stdout, "\n--normal end\n");
  return 0;
}

#else 
int main(int argc, char *argv[]) {
  return 1;
}
#endif

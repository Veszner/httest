% =========================================
% COMMAND: BLOCK
% =========================================

\newpage
\section{BLOCK}
\label{cmd:BLOCK}

\paragraph{Syntax:}
\subparagraph{}
\texttt{BLOCK <name>}

\paragraph{Purpose:}
\subparagraph{}
Begins a body with scripting code that can be invoked from anywhere 
else directly as a command. In earlier version command \texttt{_CALL} was
needed to invoke a block, you still can use this style, but is not 
neccessary anymore.

The \texttt{BLOCK} must be closed using the \texttt{END} command.

\paragraph{Parameters and Return Values}
A block can define a parameter and return values signature. You can define 
multiple parameters and return values. parameters and return values are 
separated by a ":". Parameters and return value list are separated with spaces.
Example:
\begin{usplisting}
    BLOCK myFunction myParam mySecondOne andAThirdParameter : firstReturn secondOne
      _DEBUG \$myParam
      _DEBUG \$mySecondOne
      _DEBUG \$andAThirdParameter
      _SET firstReturn=to any value
      _SET secondOne=to another value
    END 

    CLIENT
      myFunction aValue "Another one" "still not enough" RET RETVAL2
      _DEBUG \$RET
      _DEBUG \$RETVAL2
    END
\end{usplisting}

If there are no parameters and return values defined you can access parameters
with \texttt{\$1..\$n} like a shell do access its parameters.
Example:
\begin{usplisting}
    BLOCK myFunction
      _DEBUG \$1
      _DEBUG \$2
      _DEBUG \$3
      _SET \$4=A return value
      _SET \$5=And another
    END

    CLIENT
      myFunction aValue "Another one" "still not enough" RET RETVAL2
      _DEBUG \$RET
      _DEBUG \$RETVAL2
    END
\end{usplisting}

There is a special way to hand over parameters. Imagine a variable holding for
example "Hello World" and keep in mind that variable resolving is done before 
calling. You got it my variable with the value "Hello World" are suddently two
parameters, not what we want in this case. Ok there is a simple solution with by
quoting the the variable. 
Example:
\begin{usplisting}
    BLOCK myFunction p1 p2 p3
      _DEBUG \$p1
      _DEBUG \$p2
      _DEBUG \$p3
    END 

    CLIENT
      _SET myStuff=Hello World
      myFunction "\$myStuff" "next param" andStillNotEnoughParams
    END
\end{usplisting}

Imagine if your variable contains quotes and further on you got this variable 
filled up by a \texttt{_MATCH} and no way to remove or escape this quotes.
Of course even for this a solution exist. You can handover parameters with
\texttt{VAR(<param name>)}. This will not be resolved before calling the function
and therefor a complicated value will not messup your call stack.
Example:
\begin{usplisting}
    BLOCK myFunction p1 p2 p3
      _DEBUG \$p1
      _DEBUG \$p2
      _DEBUG \$p3
    END 

    CLIENT
      _SET myStuff=Hello World "and here some quotes" which will messup your parameter's
      myFunction VAR(myStuff) "next param" andStillNotEnoughParams
    END
\end{usplisting}


\paragraph{Error Handler}
\subparagraph{}
A special, reserved name for a \texttt{BLOCK} is \texttt{ON\_ERROR}. It 
designates the block to be invoked if an unexpected error occurs during 
a test. The block can then handle the error, output some information etc. 
Example:

\begin{usplisting}
    BLOCK ON_ERROR
    _DEBUG
    _DEBUG !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    _DEBUG An error occurred, please fix it and try again!
    _DEBUG !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    _DEBUG
    _EXIT FAILED
    END
\end{usplisting}
